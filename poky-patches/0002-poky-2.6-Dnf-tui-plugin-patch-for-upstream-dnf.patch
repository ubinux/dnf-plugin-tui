Subject: [PATCH] [poky-2.6] Dnf tui plugin patch for upstream dnf.

 dnf tui plugin can work on cross environment.

Signed-off-by: Zheng Ruoqin <zhengrq.fnst@cn.fujitsu.com>
---
 .../dnf/dnf/0001-dnf-tui-plugin.patch              | 7166 ++++++++++++++++++++
 .../recipes-devtools/dnf/dnf/oe-remote.repo.sample |    6 +
 meta/recipes-devtools/dnf/dnf_2.7.5.bb             |   46 +-
 3 files changed, 7217 insertions(+), 1 deletion(-)
 create mode 100644 meta/recipes-devtools/dnf/dnf/0001-dnf-tui-plugin.patch
 create mode 100644 meta/recipes-devtools/dnf/dnf/oe-remote.repo.sample

diff --git a/meta/recipes-devtools/dnf/dnf/0001-dnf-tui-plugin.patch b/meta/recipes-devtools/dnf/dnf/0001-dnf-tui-plugin.patch
new file mode 100644
index 0000000..cc53f6f
--- /dev/null
+++ b/meta/recipes-devtools/dnf/dnf/0001-dnf-tui-plugin.patch
@@ -0,0 +1,7166 @@
+Subject: [PATCH] dnf tui plugin for oe-core
+
+Add dnf tui plugin. The following functions have been developed.
+ 1. Add new command dnf tui --init to make dnf to work on host
+ 2. Dnf TUI functions
+ 3. Manage SPDX files
+ 4. Manage SRPM files
+ 5. Add installation samples for dnf
+
+Signed-off-by: Zheng Ruoqin <zhengrq.fnst@cn.fujitsu.com>
+---
+ dnf-plugins/Define.py                     |   51 +
+ dnf-plugins/dnf-host                      |  530 ++++++++++
+ dnf-plugins/fetchall.py                   |  124 +++
+ dnf-plugins/fetchspdx.py                  |  121 +++
+ dnf-plugins/fetchsrpm.py                  |  122 +++
+ dnf-plugins/mkimg/ButtonErrorWindow.py    |   33 +
+ dnf-plugins/mkimg/CheckString.py          |  120 +++
+ dnf-plugins/mkimg/ExecAndOutLog.py        |   27 +
+ dnf-plugins/mkimg/MKIMGINITRAMFSWindow.py |  296 ++++++
+ dnf-plugins/mkimg/MKIMGINITRDWindow.py    |  417 ++++++++
+ dnf-plugins/mkimg/MKIMGInfo.py            |  793 +++++++++++++++
+ dnf-plugins/mkimg/MKIMGJFFS2Window.py     |  423 ++++++++
+ dnf-plugins/mkimg/MKIMGRAWWindow.py       |  425 ++++++++
+ dnf-plugins/mkimg/MKIMGSquashFSWindow.py  |  332 ++++++
+ dnf-plugins/mkimg/MKIMGUBIFSWindow.py     |  379 +++++++
+ dnf-plugins/mkimg/OpenLogFile.py          |   27 +
+ dnf-plugins/tui.py                        | 1001 ++++++++++++++++++
+ dnf-plugins/utils.py                      |  182 ++++
+ dnf-plugins/window.py                     | 1567 +++++++++++++++++++++++++++++
+ samples/busybox                           |    7 +
+ samples/systemd                           |    5 +
+ 21 files changed, 6982 insertions(+)
+ create mode 100644 dnf-plugins/Define.py
+ create mode 100755 dnf-plugins/dnf-host
+ create mode 100755 dnf-plugins/fetchall.py
+ create mode 100755 dnf-plugins/fetchspdx.py
+ create mode 100755 dnf-plugins/fetchsrpm.py
+ create mode 100644 dnf-plugins/mkimg/ButtonErrorWindow.py
+ create mode 100644 dnf-plugins/mkimg/CheckString.py
+ create mode 100644 dnf-plugins/mkimg/ExecAndOutLog.py
+ create mode 100644 dnf-plugins/mkimg/MKIMGINITRAMFSWindow.py
+ create mode 100644 dnf-plugins/mkimg/MKIMGINITRDWindow.py
+ create mode 100644 dnf-plugins/mkimg/MKIMGInfo.py
+ create mode 100644 dnf-plugins/mkimg/MKIMGJFFS2Window.py
+ create mode 100755 dnf-plugins/mkimg/MKIMGRAWWindow.py
+ create mode 100755 dnf-plugins/mkimg/MKIMGSquashFSWindow.py
+ create mode 100755 dnf-plugins/mkimg/MKIMGUBIFSWindow.py
+ create mode 100644 dnf-plugins/mkimg/OpenLogFile.py
+ create mode 100755 dnf-plugins/tui.py
+ create mode 100755 dnf-plugins/utils.py
+ create mode 100755 dnf-plugins/window.py
+ create mode 100644 samples/busybox
+ create mode 100644 samples/systemd
+
+diff --git a/dnf-plugins/Define.py b/dnf-plugins/Define.py
+new file mode 100644
+index 0000000..b2ec3bf
+--- /dev/null
++++ b/dnf-plugins/Define.py
+@@ -0,0 +1,51 @@
++#
++# Copyright (C) Fujitsu Limited 2018 All rights reserved
++#
++
++#==================================================
++# for tui
++#==================================================
++_TXT_ROOT_TITLE = "Package Installer"
++
++#Install actions list
++#Install_actions[type][0]  :  menu item
++#Install_actions[type][1]  :  Help information
++#Install_actions[type][2]  :  Title information (optional)
++Install_actions = [("Install", "Choose it to install packages.", "About Install"), \
++                   ("Remove", "Choose it to remove packages.", "About Remove"), \
++                   ("Upgrade", "Choose it to upgrade packages.", "About Upgrade"), \
++                   ("Create binary package archive", "To create an archive that includes packages for installed packages."), \
++                   ("Create source archive", "To create an archive that includes source packages for installed packages."), \
++                   ("Create SPDX archive", "To create an archive that includes SPDX files for installed packages."), \
++                   ("Create archive(rpm, src.rpm and spdx files)", "To create an archive that includes packages, source packages and SPDX files for installed packages."), \
++
++                   ("Make filesystem image", "To make different kinds of filesystem image for root filesystem.", "About filesystem image")
++                  ]
++
++#When you choose install, list for custom install actions
++Custom_actions = [("New", "Install without package list file."), \
++                  ("Load package list file", "Load package list file")
++                  ]
++
++#Make image type list
++#Image_types[type][0]  :  menu item
++#Image_types[type][1]  :  Help information
++#Image_types[type][2]  :  Title information (optional)
++Image_types    = [("JFFS2", "Journalling Flash File System version 2.", "About JFFS2"), \
++                  ("INITRAMFS", "Initial ramdisk.", "About INITRAMFS"), \
++                  ("INITRD", "Linux initial RAM disk.", "About INITRD"), \
++                  ("RAW", "Keep the image file as the original filesystem type.", "About RAW"), \
++                  ("SquashFS", "A compressed read-only file system for Linux.", "About SquashFS"), \
++                  ("UBIFS", "Unsorted Block Image File System.", "About UBIFS")
++#                  ("Cramfs", "Compressed ROM file system.", "About Cramfs")
++                  ]
++
++#==================================================
++# for Image Maker
++#==================================================
++
++### default loop device
++DEF_DEFAULT_LOOP_DEVICE       = "/dev/loop0"
++DEF_DEFAULT_LOOP_MOUNT_POINT  = "/mnt"
++
++
+diff --git a/dnf-plugins/dnf-host b/dnf-plugins/dnf-host
+new file mode 100755
+index 0000000..b732295
+--- /dev/null
++++ b/dnf-plugins/dnf-host
+@@ -0,0 +1,530 @@
++#!/bin/bash
++
++#DEFAULT_TARGET_ ROOTFS=""
++WORKDIR=`pwd`
++DEFAULT_REPO_DIR=$WORKDIR/oe_repo
++HIDDEN_ROOTFS_DIR=$WORKDIR/.rootfs-${ARCH}
++DEFAULT_ROOTFS_DIR=/opt/ubq/devkit/$ARCH
++DEFAULT_SPDX_REPO_DIR=file://$WORKDIR/spdx_repo
++DEFAULT_SPDX_DESTINATION_DIR=$WORKDIR/spdx_download
++DEFAULT_SRPM_REPO_DIR=file://$WORKDIR/srpm_repo
++DEFAULT_SRPM_DESTINATION_DIR=$WORKDIR/srpm_download
++DEFAULT_RPM_REPO_DIR=file://$WORKDIR/oe_repo
++DEFAULT_RPM_DESTINATION_DIR=$WORKDIR/rpm_download
++TAR="false"
++
++usage () {
++    if [ ! -f $WORKDIR/.env-dnf ]; then
++        echo "Init the environment failed, please init again"
++        exit 0
++    else
++        source $WORKDIR/.env-dnf
++        echo "dnf-host is only used on host to manage packages for target."
++        echo ""
++        echo "1. If you want to create a new rootfs, you must init your environment first."
++        echo "   \$ dnf-host init "
++        echo ""
++        echo "2. If you want to manage your rootfs that has already create by dnf-host."
++        echo "   \$ dnf-host [options] COMMAND "
++        echo "   In this case, the usage is as same as dnf:"
++        echo ""
++        echo "======== Advanced OPTIONS ========"
++        echo "  -Y         Automatic yes to all prompts"
++        echo "  -D         use set -x to see what is going on"
++        echo ""
++
++        dnf -y -c ${HIDDEN_ROOTFS}/etc/dnf/dnf-host.conf --setopt=reposdir=${HIDDEN_ROOTFS}/etc/yum.repos.d --installroot=${HIDDEN_ROOTFS} --setopt=logdir=$WORKDIR/ help --releasever=None
++    fi
++    exit
++}
++
++ensure_confirm() {
++   read USER_ANSWER
++   if [ ! -n "$USER_ANSWER" ];then
++       USER_ANSWER="Y"
++   fi
++   case $USER_ANSWER in
++   N|n)
++       ;;
++   Y|y)
++       return 1
++       ;;
++   *)
++       echo "Init aborted!"
++       exit 1
++       ;;
++   esac
++}
++
++set_dir() {
++        if [ "$answer" = "Y" ]; then
++            USER_DEFINE=$1
++            echo "Set $2 directory to \"${USER_DEFINE#*//}\"."
++        else
++            echo "================================================================="
++            while true; do
++                read -p "Enter $2 directory (default: ${1#*//}): " USER_DEFINE
++                [ "$USER_DEFINE" = "" ] && USER_DEFINE=$1
++                echo "You are about to set $2 directory to \"${USER_DEFINE#*//}\". Are you sure[Y/n]?"
++                ensure_confirm
++                if [ $? = 1 ]; then
++                    break
++                fi
++            done
++        fi
++}
++
++export_env () {
++    echo "TARGET_ROOTFS=$DEFINE_ROOTFS_DIR" > $WORKDIR/.env-dnf
++    echo "HIDDEN_ROOTFS=$HIDDEN_ROOTFS_DIR" >> $WORKDIR/.env-dnf
++    echo "REPO_DIR=$DEFINE_REPO_DIR" >> $WORKDIR/.env-dnf
++    echo "SPDX_REPO_DIR=$DEFINE_SPDX_REPO_DIR" >> $WORKDIR/.env-dnf
++    echo "SPDX_DESTINATION_DIR=$DEFINE_SPDX_DESTINATION_DIR" >> $WORKDIR/.env-dnf
++    echo "SRPM_REPO_DIR=$DEFINE_SRPM_REPO_DIR" >> $WORKDIR/.env-dnf
++    echo "SRPM_DESTINATION_DIR=$DEFINE_SRPM_DESTINATION_DIR" >> $WORKDIR/.env-dnf
++    echo "RPM_REPO_DIR=$DEFINE_RPM_REPO_DIR" >> $WORKDIR/.env-dnf
++    echo "RPM_DESTINATION_DIR=$DEFINE_RPM_DESTINATION_DIR" >> $WORKDIR/.env-dnf
++    echo "LD_LIBRARY_PATH=$OECORE_NATIVE_SYSROOT/usr/bin/../lib/pseudo/lib:$OECORE_NATIVE_SYSROOT/usr/bin/../lib/pseudo/lib64" >> $WORKDIR/.env-dnf
++    echo "LD_PRELOAD=libpseudo.so" >> $WORKDIR/.env-dnf
++    echo "PSEUDO_PASSWD=$HIDDEN_ROOTFS_DIR" >> $WORKDIR/.env-dnf
++    echo "PSEUDO_OPTS=" >> $WORKDIR/.env-dnf
++    echo "PSEUDO_LIBDIR=$OECORE_NATIVE_SYSROOT/usr/bin/../lib/pseudo/lib64" >> $WORKDIR/.env-dnf
++    echo "PSEUDO_NOSYMLINKEXP=1" >> $WORKDIR/.env-dnf
++    echo "PSEUDO_DISABLED=0" >> $WORKDIR/.env-dnf
++    echo "PSEUDO_PREFIX=$OECORE_NATIVE_SYSROOT/usr" >> $WORKDIR/.env-dnf
++    echo "PSEUDO_LOCALSTATEDIR=$WORKDIR/pseudo/" >> $WORKDIR/.env-dnf
++    echo "D=$HIDDEN_ROOTFS_DIR" >> $WORKDIR/.env-dnf
++    echo "OFFLINE_ROOT=$HIDDEN_ROOTFS_DIR" >> $WORKDIR/.env-dnf
++    echo "IPKG_OFFLINE_ROOT=$HIDDEN_ROOTFS_DIR" >> $WORKDIR/.env-dnf
++    echo "OPKG_OFFLINE_ROOT=$HIDDEN_ROOTFS_DIR" >> $WORKDIR/.env-dnf
++    echo "INTERCEPT_DIR=$WORKDIR/intercept_scripts" >> $WORKDIR/.env-dnf
++    echo "NATIVE_ROOT=$OECORE_NATIVE_SYSROOT" >> $WORKDIR/.env-dnf
++    echo "RPM_ETCCONFIGDIR=$HIDDEN_ROOTFS_DIR" >> $WORKDIR/.env-dnf
++}
++
++check_para () {
++#Check the parameters
++if [ ! -d $HIDDEN_ROOTFS_DIR ]; then
++    echo " $HIDDEN_ROOTFS_DIR is not exist. mkdir $HIDDEN_ROOTFS_DIR. "
++    mkdir -p $HIDDEN_ROOTFS_DIR
++fi
++}
++
++#create repodata for rpm packages.
++create_repo () {
++    if [ ${DEFINE_REPO_DIR:0:4} = "http" ];then
++        echo "This is a remote repo!"
++    else
++        if [ ! -d $DEFINE_REPO_DIR ]; then
++            echo "Error! $DEFINE_REPO_DIR is not exist. Please Check your rpm repo! "
++            exit 0
++        fi
++        echo "Creating repo ..."
++        if [ -f $DEFINE_REPO_DIR/comps.xml ]; then
++            createrepo_c.real --update -q -g comps.xml $DEFINE_REPO_DIR
++        else
++            createrepo_c.real --update -q $DEFINE_REPO_DIR
++        fi
++    fi
++}
++
++travFolder () {
++    cd $1
++    for f in `ls`
++    do
++        if [ "$f" = "repodata" ];then
++           continue
++        fi
++        if test -d $f;then
++            travFolder $f
++        else
++            if [ "${f##*.}"x = "rpm"x ];then
++                rate=$(echo "scale=2;$i/$all_pkg"|bc)
++                percent=$(echo "$rate*100"|bc)
++                #percent=${percent%.*} #transform float to integer
++                num=$(echo "$rate*50+1"|bc)
++                bar="`seq -s '#' $num | sed 's/[0-9]//g'`"
++                printf "progress:[%-50s]%.0f%%\r" "$bar" "$percent"
++                let i=i+1
++
++                line=`echo "$f" | sed -r 's/.*\.(.*)\.rpm/\1/'`
++                if [ "$line" != "all" ] && [ "$line" != "any" ] && [ "$line" != "noarch" ] && [ "$line" != "${ARCH}" ] && [ "$line" != "${MACHINE_ARCH}" ]; then
++                    grep -w "$line" $HIDDEN_ROOTFS_DIR/etc/dnf/vars/arch > /dev/null
++                    if [ $? -ne 0 ]; then
++                        echo -n "$line:" >> $HIDDEN_ROOTFS_DIR/etc/dnf/vars/arch
++                        echo -n " $line" >> $HIDDEN_ROOTFS_DIR/etc/rpmrc
++                    fi
++                fi
++            fi
++            continue
++        fi
++    done
++    cd - >/dev/null
++}
++
++config_dnf () {
++    #necessary dnf config
++    if [ ! -d $HIDDEN_ROOTFS_DIR/etc/dnf ]; then
++        mkdir -p $HIDDEN_ROOTFS_DIR/etc/dnf
++        touch $HIDDEN_ROOTFS_DIR/etc/dnf/dnf-host.conf
++    fi
++
++    #clean the original content in dnf.conf file
++    #Add config_path in dnf.conf file
++
++cat > $HIDDEN_ROOTFS_DIR/etc/dnf/dnf-host.conf <<EOF
++[main]
++spdx_repodir=$DEFINE_SPDX_REPO_DIR
++spdx_download=$DEFINE_SPDX_DESTINATION_DIR
++srpm_repodir=$DEFINE_SRPM_REPO_DIR
++srpm_download=$DEFINE_SRPM_DESTINATION_DIR
++rpm_repodir=$DEFINE_RPM_REPO_DIR
++rpm_download=$DEFINE_RPM_DESTINATION_DIR
++
++installroot=$HIDDEN_ROOTFS_DIR
++logdir=$WORKDIR
++releasever=None
++EOF
++
++    #Config local repo for cross environment
++    mkdir -p $HIDDEN_ROOTFS_DIR/etc/yum.repos.d
++
++cat > $HIDDEN_ROOTFS_DIR/etc/yum.repos.d/oe.repo  <<EOF
++[base]
++name=oe_repo
++baseurl=file://$DEFINE_REPO_DIR
++enabled=1
++gpgcheck=0
++EOF
++
++    if [ ! -d $HIDDEN_ROOTFS_DIR/etc/dnf/vars ]; then
++        mkdir -p $HIDDEN_ROOTFS_DIR/etc/dnf/vars
++        echo -n "${MACHINE_ARCH}:${ARCH}:" >> $HIDDEN_ROOTFS_DIR/etc/dnf/vars/arch
++    fi
++
++    #necessary rpm config
++    if [ ! -d $HIDDEN_ROOTFS_DIR/etc/rpm ] || [ ! -f $HIDDEN_ROOTFS_DIR/etc/rpm/platform ]; then
++        mkdir -p $HIDDEN_ROOTFS_DIR/etc/rpm
++        echo "${MACHINE_ARCH}-pc-linux" > $HIDDEN_ROOTFS_DIR/etc/rpm/platform
++    fi
++
++    if [ ! -f $HIDDEN_ROOTFS_DIR/etc/rpmrc ]; then
++        echo -n "arch_compat: ${MACHINE_ARCH}: all any noarch ${ARCH} ${MACHINE_ARCH}" > $HIDDEN_ROOTFS_DIR/etc/rpmrc
++    fi
++
++    if [ ${DEFINE_REPO_DIR:0:4} = "http" ];then
++
++cat > $HIDDEN_ROOTFS_DIR/etc/yum.repos.d/oe.repo  <<EOF
++[base]
++name=oe_repo
++baseurl=$DEFINE_REPO_DIR
++enabled=1
++gpgcheck=0
++EOF
++    else
++        echo "Scanning repo ..."
++        all_pkg=`ls -lR $DEFINE_REPO_DIR | grep "^-" |grep rpm$ |wc -l`
++        i=1
++        travFolder $DEFINE_REPO_DIR
++        echo -e "\nScanning finish"
++        sed -i "s/:$/\n/g" $HIDDEN_ROOTFS_DIR/etc/dnf/vars/arch
++        sed -i "s/:$//g" $HIDDEN_ROOTFS_DIR/etc/rpmrc
++    fi
++}
++
++dnf-init() {
++    if [ -f .env-dnf ];then
++        rm .env-dnf
++    fi
++    if [ -d $HIDDEN_ROOTFS_DIR ];then
++        echo "Deleting temp rootfs......"
++        rm -rf $HIDDEN_ROOTFS_DIR
++    fi
++
++    #get repo directory
++    set_dir $DEFAULT_REPO_DIR "repo"
++    DEFINE_REPO_DIR=$USER_DEFINE
++
++    #get rootfs destination directory
++    set_dir $DEFAULT_ROOTFS_DIR "rootfs destination"
++    DEFINE_ROOTFS_DIR=$USER_DEFINE
++
++    #get SPDX repo directory
++    set_dir $DEFAULT_SPDX_REPO_DIR "SPDX repo"
++    DEFINE_SPDX_REPO_DIR=$USER_DEFINE
++
++    #Add 'file://' for SPDX_REPO_DIR
++    if [ ${DEFINE_SPDX_REPO_DIR:0:4} != "file" ];then
++        DEFINE_SPDX_REPO_DIR=file://${DEFINE_SPDX_REPO_DIR}
++    fi
++
++    #get SPDX file destination directory
++    set_dir $DEFAULT_SPDX_DESTINATION_DIR "SPDX file destination"
++    DEFINE_SPDX_DESTINATION_DIR=$USER_DEFINE
++
++    if [ ! -d $DEFINE_SPDX_DESTINATION_DIR ];then
++        echo "Create the SPDX file destination directory automatically"
++        mkdir -p $DEFINE_SPDX_DESTINATION_DIR
++    fi
++
++    #get SRPM repo directory
++    set_dir $DEFAULT_SRPM_REPO_DIR "SRPM repo"
++    DEFINE_SRPM_REPO_DIR=$USER_DEFINE
++
++    #Add 'file://' for SRPM_REPO_DIR
++    if [ ${DEFINE_SRPM_REPO_DIR:0:4} != "file" ];then
++        DEFINE_SRPM_REPO_DIR=file://${DEFINE_SRPM_REPO_DIR}
++    fi
++
++    #get SRPM file destination directory
++    set_dir $DEFAULT_SRPM_DESTINATION_DIR "SRPM file destination"
++    DEFINE_SRPM_DESTINATION_DIR=$USER_DEFINE
++
++    if [ ! -d $DEFINE_SRPM_DESTINATION_DIR ];then
++        echo "Create the SRPM file destination directory automatically"
++        mkdir -p $DEFINE_SRPM_DESTINATION_DIR
++    fi
++
++    #get RPM repo directory
++    set_dir $DEFAULT_RPM_REPO_DIR "RPM repo"
++    DEFINE_RPM_REPO_DIR=$USER_DEFINE
++
++    #Add 'file://' for RPM_REPO_DIR
++    if [ ${DEFINE_RPM_REPO_DIR:0:4} != "file" ];then
++        DEFINE_RPM_REPO_DIR=file://${DEFINE_RPM_REPO_DIR}
++    fi
++
++    #get RPM file destination directory
++    set_dir $DEFAULT_RPM_DESTINATION_DIR "RPM file destination"
++    DEFINE_RPM_DESTINATION_DIR=$USER_DEFINE
++
++    if [ ! -d $DEFINE_RPM_DESTINATION_DIR ];then
++        echo "Create the RPM file destination directory automatically"
++        mkdir -p $DEFINE_RPM_DESTINATION_DIR
++    fi
++
++    #Delete the prefix "file://" in REPO_DIR
++    if [ ${DEFINE_REPO_DIR:0:4} = "file" ];then
++        DEFINE_REPO_DIR=${DEFINE_REPO_DIR#*//}
++    fi
++
++    #Start from here
++    export_env
++    check_para
++    create_repo
++    config_dnf
++}
++
++dnf-show() {
++    if [ ! -f $WORKDIR/.env-dnf ]; then
++        echo "Init the environment failed, please init again"
++        exit 0
++    else
++        source $WORKDIR/.env-dnf
++        echo "repo directory : ${REPO_DIR}"
++        echo "rootfs destination directory : ${TARGET_ROOTFS}"
++        echo "SPDX repo directory : ${SPDX_REPO_DIR}"
++        echo "SPDX destination directory : ${SPDX_DESTINATION_DIR}"
++        echo "SRPM repo directory : ${SRPM_REPO_DIR}"
++        echo "SRPM destination directory : ${SRPM_DESTINATION_DIR}"
++    fi
++}
++
++print_progess() {
++    let bar_num=$1
++    bar="`seq -s '#' $bar_num | sed 's/[0-9]//g'`"
++    printf "\rprogress:[%-50s]%.0f%%" "$bar" "$2"
++}
++
++#compress_or_decompress rootfs
++#parameter
++#$1 is tar file name
++#$2 is tared directory
++compress_or_decompress() {
++    total_files=$( ls . -lR | grep rw | wc -l ) #num of all files in rootfs
++
++    #used to accpet the output of tar
++    tmpfifo=/tmp/tmpfifo
++    if [  -f $tmpfifo ];then
++    :
++    else
++        mkfifo $tmpfifo &> /dev/null
++    fi
++    (
++    current_file_num=0
++    compressed_file_num=0
++    progress_num=0
++
++    # Read the output of tar
++    while read line
++    do
++        current_file_num=$(echo $line | wc -l )
++        let compressed_file_num=${compressed_file_num}+${current_file_num}
++        rate=$(echo "scale=2;$compressed_file_num/$total_files"|bc)
++        percent=$(echo "$rate*100"|bc)  #Already completed percent
++        num=$(echo "$rate*50+1"|bc)     #progress bar num
++        progress_num=${num%.*}          #transform float to integer
++        sleep 0.01
++        print_progess $progress_num $percent
++        if [ ${compressed_file_num} -ge ${total_files} ]; then
++            print_progess 51 100
++            rm -rf $tmpfifo
++            break
++        fi
++    done<$tmpfifo
++    echo
++    ) &
++    child_PID=$!
++
++    #call tar execution
++    if [ $2 == "-C" ];then
++        sudo tar xjvvf "$@" >$tmpfifo 2>/dev/null
++    else
++        tar cjvf "$@" >$tmpfifo 2>/dev/null
++    fi
++    wait ${child_PID}
++    return ${total_files}
++}
++
++# 1. Compress the rootfs to tarball
++# 2. Decompress tarball to rootfs destination
++Put_rootfs_to_destination(){
++    cd ${HIDDEN_ROOTFS}
++    echo "Prepare rootfs"
++    compress_or_decompress ../${ROOTFS_TAR} ./*
++    unset LD_PRELOAD
++
++    # Check whether the tar ball has been produced
++    if [ ! -f ../${ROOTFS_TAR} ];then
++        echo "No file named ${ROOTFS_TAR}"
++        exit 1
++    fi
++
++    sudo mkdir -p ${TARGET_ROOTFS}/rootfs-${RELEASE}-${Date}
++    echo "Put rootfs to destination"
++    compress_or_decompress ../${ROOTFS_TAR} -C ${TARGET_ROOTFS}/rootfs-${RELEASE}-${Date} --numeric-owner
++    sudo rm ${TARGET_ROOTFS}/rootfs-${RELEASE}-${Date}/etc/dnf/dnf-host.conf
++    sudo rm ${TARGET_ROOTFS}/rootfs-${RELEASE}-${Date}/etc/yum.repos.d/oe.repo
++
++    # Ask user whether they need to keep the tar file of rootfs
++    echo "Do you like to keep the tarball of rootfs.[Y/n]?"
++    read USER_ANSWER
++    if [ ! -n "$USER_ANSWER" ];then
++        USER_ANSWER="Y"
++    fi
++    case $USER_ANSWER in
++    N|n)
++        rm -f ../${ROOTFS_TAR}
++        ;;
++    Y|y)
++        echo "The tarball is ${WORKDIR}/${ROOTFS_TAR}"
++        ;;
++    *)
++        echo "The tarball is ${WORKDIR}/${ROOTFS_TAR}"
++        ;;
++    esac
++
++    if [ ! -d ${TARGET_ROOTFS}/rootfs-${RELEASE}-${Date} ]; then
++        echo "The operation has been interrupted"
++        exit 1
++    fi
++    echo "Target dir is ${TARGET_ROOTFS}/rootfs-${RELEASE}-${Date}"
++}
++
++Install_pkg_from_listfile(){
++      #Check if package list file is exist
++      if [ -f $INSTALL_LIST ]; then
++          PKG_LIST=`cat $INSTALL_LIST`
++          check_results=`dnf -y -c ${HIDDEN_ROOTFS}/etc/dnf/dnf-host.conf --setopt=reposdir=${HIDDEN_ROOTFS}/etc/yum.repos.d --repofrompath=oe-repo,${REPO_DIR} --installroot=${HIDDEN_ROOTFS} --setopt=logdir=$WORKDIR/ --nogpgcheck $* install $PKG_LIST --releasever=None`
++
++          #If no packages are installed, exit
++          if echo "$check_results" | grep "Nothing to do."; then
++              echo "All packages are already installed"
++              exit 0
++          fi
++
++          if $FETCH_ALL; then
++              dnf -c ${HIDDEN_ROOTFS}/etc/dnf/dnf-host.conf --installroot=${HIDDEN_ROOTFS} fetchall $PKG_LIST
++          fi
++      else
++          echo "$INSTALL_LIST: No such file, please check your input!"
++          exit 0
++      fi
++}
++
++dnf-call() {
++    if [ ! -f $WORKDIR/.env-dnf ]; then
++        echo "Init the environment failed, please init again"
++        exit 0
++    else
++        source $WORKDIR/.env-dnf
++
++        #install from package list file
++        if [ -n "$INSTALL_LIST" ]; then
++            Install_pkg_from_listfile
++        fi
++
++        Date=`date +%Y%m%d%H%M`
++        RELEASE=`echo $STRIP |awk -F '-' '{print $2}'`
++        ROOTFS_TAR=rootfs-${RELEASE}-${Date}.tar.bz2
++
++        #When you choose tui, the rootfs will be made only after pkg operation
++        if [ $TAR = "true" ]; then
++            Put_rootfs_to_destination
++        fi
++    fi
++}
++
++#Main function start from here
++#if args is none, show usage
++if [ $# -eq 0 ]; then
++    usage
++fi
++
++ARGS_ORG=$*
++ARGS_ORG=`echo $ARGS_ORG | sed 's/-D//' | sed 's/-Y//'| sed 's/--rootfs-tar//'| sed 's/--install_list//'`
++
++ARGS=`getopt -q -a -o hDY -l install_list:,help,rootfs-tar -- "$@"`
++
++eval set -- "${ARGS}"
++while true
++do
++        case "$1" in
++        -h|--help)
++                usage
++                shift
++                ;;
++        --rootfs-tar)
++                TAR="true"
++                shift
++                ;;
++        --install_list)
++                INSTALL_LIST=$2
++                shift 2
++                ;;
++        --fetch-all)
++                FETCH_ALL="true"
++                ;;
++        -D)
++                set -x
++                shift
++                ;;
++        -Y)
++                answer="Y"
++                shift
++                ;;
++        --)
++                shift
++                break
++                ;;
++        esac
++done
++
++#Deal residual args
++if [ "$1"x = "init"x -a $# = 1 ]; then
++    dnf-init
++elif [ "$1"x = "show"x ]; then
++    dnf-show
++else
++    dnf-call $ARGS_ORG
++fi
+diff --git a/dnf-plugins/fetchall.py b/dnf-plugins/fetchall.py
+new file mode 100755
+index 0000000..24d0e44
+--- /dev/null
++++ b/dnf-plugins/fetchall.py
+@@ -0,0 +1,124 @@
++# fetchspdx
++# Fetch_spdx CLI command.
++#
++# Copyright (C) 2014-2016 Red Hat, Inc.
++#
++# This copyrighted material is made available to anyone wishing to use,
++# modify, copy, or redistribute it subject to the terms and conditions of
++# the GNU General Public License v.2, or (at your option) any later version.
++# This program is distributed in the hope that it will be useful, but WITHOUT
++# ANY WARRANTY expressed or implied, including the implied warranties of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
++# Public License for more details.  You should have received a copy of the
++# GNU General Public License along with this program; if not, write to the
++# Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
++# 02110-1301, USA.  Any Red Hat trademarks that are incorporated in the
++# source code or documentation are not subject to the GNU General Public
++# License and may only be used or replicated with the express permission of
++# Red Hat, Inc.
++#
++
++from __future__ import absolute_import
++from __future__ import unicode_literals
++from dnf.cli import commands
++from dnf.cli.option_parser import OptionParser
++from dnf.i18n import _
++from itertools import chain
++import dnf.subject
++import dnf.plugin
++
++import dnf.exceptions
++import hawkey
++import logging
++from .utils import *
++from subprocess import call
++import sys
++
++logger = logging.getLogger('dnf')
++
++@dnf.plugin.register_command
++class Fetch_spdxCommand(commands.Command):
++    """A class containing methods needed by the cli to execute the
++    install command.
++    """
++    nevra_forms = {'install-n': hawkey.FORM_NAME,
++                   'install-na': hawkey.FORM_NA,
++                   'install-nevra': hawkey.FORM_NEVRA}
++
++    aliases = ('fetchall',)
++    summary = _('download spdx file and source package of package on your system')
++
++    @staticmethod
++    def set_argparser(parser):
++        parser.add_argument('package', nargs='+', metavar=_('PACKAGE'),
++                          action=OptionParser.ParseSpecGroupFileCallback,
++                          help=_('Package to download'))
++        parser.add_argument("--call", dest="with_call",
++                          action="store_true", default=None,
++                          help=_("Call the dnf tui for toolchain"))
++
++    def pre_configure(self):
++        if self.opts.with_call:
++            return
++        else:
++            #Reload the conf and args
++            env_path = os.getcwd() + "/.env-dnf"
++            if os.path.exists(env_path):
++                read_environ(env_path)
++                install_root_from_env = os.environ['HIDDEN_ROOTFS']
++                self.opts.installroot = install_root_from_env
++                self.opts.config_file_path = install_root_from_env + "/etc/dnf/dnf-host.conf"
++                self.opts.logdir = os.path.dirname(install_root_from_env)
++
++                #call subprocess dnf
++                dnf_args = ["dnf", "fetchall", "--call", "-c{}".format(
++                            self.opts.config_file_path), "--installroot={}".format(
++                            self.opts.installroot), "--setopt=logdir={}".format(
++                            self.opts.logdir), "--releasever=None"] + self.opts.pkg_specs
++
++                exit_code = call(dnf_args)
++                if exit_code != 0:
++                    raise dnf.exceptions.Error(_("Failed to call dnf fetchspdx"))
++                sys.exit(0)
++
++    def configure(self):
++        """Verify that conditions are met so that this command can run.
++        That there are enabled repositories with gpg keys, and that
++        this command is called with appropriate arguments.
++        """
++        demands = self.cli.demands
++        demands.sack_activation = True
++        demands.available_repos = True
++        demands.resolving = True
++        self.forms = [self.nevra_forms[command] for command in self.opts.command
++                      if command in list(self.nevra_forms.keys())]
++
++    def fetchALL(self, pkg_specs):
++        '''Obtain yum package list '''
++        ypl = self.base.returnPkgLists(
++                pkgnarrow = 'all', patterns = pkg_specs)
++
++        # check if the pkg can be found
++        if ypl.available or ypl.installed:
++            install_pkgs = ypl.available + ypl.installed
++        else:
++            logger.info(_("Error: No matches found."))
++            return
++
++        fetchSPDXorSRPM('rpm', install_pkgs,
++                    os.environ['RPM_REPO_DIR'], os.environ['RPM_DESTINATION_DIR'])
++        notype_pkgs = PKG_filter(install_pkgs)
++        fetchSPDXorSRPM('srpm', notype_pkgs,
++                    os.environ['SRPM_REPO_DIR'], os.environ['SRPM_DESTINATION_DIR'])
++        fetchSPDXorSRPM('spdx', notype_pkgs,
++                    os.environ['SPDX_REPO_DIR'], os.environ['SPDX_DESTINATION_DIR'])
++
++
++    def run(self):
++        if self.opts.installroot:  #if used in toolchain
++            if self.opts.with_call:
++                self.fetchALL(self.opts.pkg_specs)
++
++        else:
++            self.fetchALL(self.opts.pkg_specs)
++
+diff --git a/dnf-plugins/fetchspdx.py b/dnf-plugins/fetchspdx.py
+new file mode 100755
+index 0000000..b6a0ad8
+--- /dev/null
++++ b/dnf-plugins/fetchspdx.py
+@@ -0,0 +1,121 @@
++# fetchspdx
++# Fetch_spdx CLI command.
++#
++# Copyright (C) 2014-2016 Red Hat, Inc.
++#
++# This copyrighted material is made available to anyone wishing to use,
++# modify, copy, or redistribute it subject to the terms and conditions of
++# the GNU General Public License v.2, or (at your option) any later version.
++# This program is distributed in the hope that it will be useful, but WITHOUT
++# ANY WARRANTY expressed or implied, including the implied warranties of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
++# Public License for more details.  You should have received a copy of the
++# GNU General Public License along with this program; if not, write to the
++# Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
++# 02110-1301, USA.  Any Red Hat trademarks that are incorporated in the
++# source code or documentation are not subject to the GNU General Public
++# License and may only be used or replicated with the express permission of
++# Red Hat, Inc.
++#
++
++from __future__ import absolute_import
++from __future__ import unicode_literals
++from dnf.cli import commands
++from dnf.cli.option_parser import OptionParser
++from dnf.i18n import _
++from itertools import chain
++import dnf.subject
++import dnf.plugin
++
++import dnf.exceptions
++import hawkey
++import logging
++from .utils import *
++from subprocess import call
++import sys
++
++logger = logging.getLogger('dnf')
++
++@dnf.plugin.register_command
++class Fetch_spdxCommand(commands.Command):
++    """A class containing methods needed by the cli to execute the
++    install command.
++    """
++    nevra_forms = {'install-n': hawkey.FORM_NAME,
++                   'install-na': hawkey.FORM_NA,
++                   'install-nevra': hawkey.FORM_NEVRA}
++
++    aliases = ('fetchspdx',)
++    summary = _('download a spdx file of package on your system')
++
++    @staticmethod
++    def set_argparser(parser):
++        parser.add_argument('package', nargs='+', metavar=_('PACKAGE'),
++                          action=OptionParser.ParseSpecGroupFileCallback,
++                          help=_('Package to download'))
++        parser.add_argument("--call", dest="with_call",
++                          action="store_true", default=None,
++                          help=_("Call the dnf tui for toolchain"))
++
++    def pre_configure(self):
++        if self.opts.with_call:
++            return
++        else:
++            #Reload the conf and args
++            env_path = os.getcwd() + "/.env-dnf"
++            if os.path.exists(env_path):
++                read_environ(env_path)
++                install_root_from_env = os.environ['HIDDEN_ROOTFS']
++                self.opts.installroot = install_root_from_env
++                self.opts.config_file_path = install_root_from_env + "/etc/dnf/dnf-host.conf"
++                self.opts.logdir = os.path.dirname(install_root_from_env)
++
++                #call subprocess dnf
++                dnf_args = ["dnf", "fetchspdx", "--call", "-c{}".format(
++                            self.opts.config_file_path), "--installroot={}".format(
++                            self.opts.installroot), "--setopt=logdir={}".format(
++                            self.opts.logdir), "--releasever=None"] + self.opts.pkg_specs
++
++                exit_code = call(dnf_args)
++                if exit_code != 0:
++                    raise dnf.exceptions.Error(_("Failed to call dnf fetchspdx"))
++                sys.exit(0)
++
++    def configure(self):
++        """Verify that conditions are met so that this command can run.
++        That there are enabled repositories with gpg keys, and that
++        this command is called with appropriate arguments.
++        """
++        demands = self.cli.demands
++        demands.sack_activation = True
++        demands.available_repos = True
++        demands.resolving = True
++        self.forms = [self.nevra_forms[command] for command in self.opts.command
++                      if command in list(self.nevra_forms.keys())]
++
++    def fetchSPDX(self, pkg_specs):
++        """Add for spdx file cp."""
++        srcdir_path = os.environ['SPDX_REPO_DIR']
++        destdir_path = os.environ['SPDX_DESTINATION_DIR']
++
++        '''Obtain yum package list '''
++        ypl = self.base.returnPkgLists(
++                pkgnarrow = 'all', patterns = pkg_specs)
++
++        # check if the pkg can be found
++        if ypl.available or ypl.installed:
++            install_pkgs = ypl.available + ypl.installed
++        else:
++            logger.info(_("Error: No matches found."))
++            return
++
++        fetchSPDXorSRPM('spdx', install_pkgs, srcdir_path, destdir_path)
++
++    def run(self):
++        if self.opts.installroot:  #if used in toolchain
++            if self.opts.with_call:
++                self.fetchSPDX(self.opts.pkg_specs)
++
++        else:
++            self.fetchSPDX(self.opts.pkg_specs)
++
+diff --git a/dnf-plugins/fetchsrpm.py b/dnf-plugins/fetchsrpm.py
+new file mode 100755
+index 0000000..5282f09
+--- /dev/null
++++ b/dnf-plugins/fetchsrpm.py
+@@ -0,0 +1,122 @@
++# fetchspdx
++# Fetch_spdx CLI command.
++#
++# Copyright (C) 2014-2016 Red Hat, Inc.
++#
++# This copyrighted material is made available to anyone wishing to use,
++# modify, copy, or redistribute it subject to the terms and conditions of
++# the GNU General Public License v.2, or (at your option) any later version.
++# This program is distributed in the hope that it will be useful, but WITHOUT
++# ANY WARRANTY expressed or implied, including the implied warranties of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
++# Public License for more details.  You should have received a copy of the
++# GNU General Public License along with this program; if not, write to the
++# Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
++# 02110-1301, USA.  Any Red Hat trademarks that are incorporated in the
++# source code or documentation are not subject to the GNU General Public
++# License and may only be used or replicated with the express permission of
++# Red Hat, Inc.
++#
++
++from __future__ import absolute_import
++from __future__ import unicode_literals
++from dnf.cli import commands
++from dnf.cli.option_parser import OptionParser
++from dnf.i18n import _
++from itertools import chain
++import dnf.subject
++import dnf.plugin
++
++import dnf.exceptions
++import hawkey
++import logging
++from .utils import *
++from subprocess import call
++import sys
++
++logger = logging.getLogger('dnf')
++
++@dnf.plugin.register_command
++class Fetch_srpmCommand(commands.Command):
++    """A class containing methods needed by the cli to execute the
++    install command.
++    """
++    nevra_forms = {'install-n': hawkey.FORM_NAME,
++                   'install-na': hawkey.FORM_NA,
++                   'install-nevra': hawkey.FORM_NEVRA}
++
++    aliases = ('fetchsrpm',)
++    summary = _('Download a srpm file of package on your system')
++
++    @staticmethod
++    def set_argparser(parser):
++        parser.add_argument('package', nargs='+', metavar=_('PACKAGE'),
++                          action=OptionParser.ParseSpecGroupFileCallback,
++                          help=_('Package to download'))
++        parser.add_argument("--call", dest="with_call",
++                          action="store_true", default=None,
++                          help=_("Call the dnf tui for toolchain"))
++
++    def pre_configure(self):
++        if self.opts.with_call:
++            return
++        else:
++            #Reload the conf and args
++            env_path = os.getcwd() + "/.env-dnf"
++            if os.path.exists(env_path):
++                read_environ(env_path)
++                install_root_from_env = os.environ['HIDDEN_ROOTFS']
++                self.opts.installroot = install_root_from_env
++                self.opts.config_file_path = install_root_from_env + "/etc/dnf/dnf-host.conf"
++                self.opts.logdir = os.path.dirname(install_root_from_env)
++
++                #call subprocess dnf
++                dnf_args = ["dnf", "fetchsrpm", "--call", "-c{}".format(
++                            self.opts.config_file_path), "--installroot={}".format(
++                            self.opts.installroot), "--setopt=logdir={}".format(
++                            self.opts.logdir), "--releasever=None"] + self.opts.pkg_specs
++
++                exit_code = call(dnf_args)
++                if exit_code != 0:
++                    raise dnf.exceptions.Error(_("Failed to call dnf fetchspdx"))
++
++                sys.exit(0)
++
++    def configure(self):
++        """Verify that conditions are met so that this command can run.
++        That there are enabled repositories with gpg keys, and that
++        this command is called with appropriate arguments.
++        """
++        demands = self.cli.demands
++        demands.sack_activation = True
++        demands.available_repos = True
++        demands.resolving = True
++        self.forms = [self.nevra_forms[command] for command in self.opts.command
++                      if command in list(self.nevra_forms.keys())]
++
++    def fetchSRPM(self, pkg_specs):
++        """Add for spdx file cp."""
++        srcdir_path = os.environ['SRPM_REPO_DIR']
++        destdir_path = os.environ['SRPM_DESTINATION_DIR']
++
++        '''Obtain yum package list '''
++        ypl = self.base.returnPkgLists(
++                pkgnarrow = 'all', patterns = pkg_specs)
++
++        #check if the pkg can be found
++        if ypl.available or ypl.installed:
++            install_pkgs = ypl.available + ypl.installed
++        else:
++            logger.info(_("Error: No matches found."))
++            return
++
++        fetchSPDXorSRPM('srpm', install_pkgs, srcdir_path, destdir_path)
++
++    def run(self):
++        if self.opts.installroot:  #if used in toolchain
++            if self.opts.with_call:
++                self.fetchSRPM(self.opts.pkg_specs)
++
++        else:
++            self.fetchSRPM(self.opts.pkg_specs)
++
+diff --git a/dnf-plugins/mkimg/ButtonErrorWindow.py b/dnf-plugins/mkimg/ButtonErrorWindow.py
+new file mode 100644
+index 0000000..88095ed
+--- /dev/null
++++ b/dnf-plugins/mkimg/ButtonErrorWindow.py
+@@ -0,0 +1,33 @@
++#
++# Copyright (C) Fujitsu Limited 2018 All rights reserved
++#
++
++import snack, sys
++
++from ..window import ButtonInfoWindow
++
++#------------------------------------------------------------
++# def ButtonErrorWindow()
++#
++#   Display Error Window.
++#
++# Input:
++#    insScreen : screen instance
++# Output:
++#    -
++#------------------------------------------------------------
++def ButtonErrorWindow(insScreen, sItem):
++    buttons = ["OK"]
++
++    lst_text = []
++    lst_text.append("   The following data is invalid\n\n")
++    lst_text.append("   - " + sItem)
++
++    main_text = "".join(lst_text)
++    del lst_text
++
++    rcode = ButtonInfoWindow(insScreen, "Error", main_text, 80, 4, buttons)
++
++    if rcode == "y":
++        sys.exit(0)
++
+diff --git a/dnf-plugins/mkimg/CheckString.py b/dnf-plugins/mkimg/CheckString.py
+new file mode 100644
+index 0000000..5816be9
+--- /dev/null
++++ b/dnf-plugins/mkimg/CheckString.py
+@@ -0,0 +1,120 @@
++#
++# Copyright (C) Fujitsu Limited 2018 All rights reserved
++#
++
++import string
++
++#-----------------------------------------------------------
++# def CheckString()
++#
++#   Check characters in string
++#
++# Input:
++#   sValue : string
++# Output:
++#   int    : 0 = success, -1 = fail
++#-----------------------------------------------------------
++def CheckString(sValue):
++    tmp = sValue
++
++    # No input
++    if len(tmp) == 0:
++        return -1
++
++    # Number typ Check
++    typ = CheckDigitHex(tmp)
++    tmp = tmp.lower()
++
++    # digit check
++    if typ == 10:
++        # check character exist (!kb,mb,k,m,b)
++        chara = Check10Chara(tmp)
++        if chara != 0:
++            return -1
++
++        # size check
++        pos = len(tmp)
++        if tmp[-1:] == "k" or tmp[-1:] == "m":
++            pos = -1
++
++        if int(tmp[:pos], 10) == 0:
++            return -1
++
++    # hex digit check
++    if typ == 16:
++        # check character exist (!a-f)
++        chara = Check16Chara(tmp)
++        if chara != 0:
++            return -1
++
++        # size check
++        if int(tmp, 16) == 0:
++            return -1
++
++    return 0
++
++
++#-----------------------------------------------------------
++# def Check10Chara()
++#
++#   Check characters other than the decimal number
++#
++# Input:
++#   sValue : string
++# Output:
++#   int    : 0 = success, -1 = fail
++#-----------------------------------------------------------
++def Check10Chara(sValue):
++    rcode = 0
++
++    pos = len(sValue)
++    if sValue[-1:] == "k" or sValue[-1:] == "m":
++        pos = -1
++
++    #if sValue include srting
++    if not sValue[:pos].isdigit():
++        rcode = -1
++
++    return rcode
++
++
++#-----------------------------------------------------------
++# def Check16Chara()
++#
++#   Check characters other than the hexadecimal number
++#
++# Input:
++#   sValue : string
++# Output:
++#   int    : 0 = success, -1 = fail
++#-----------------------------------------------------------
++def Check16Chara(sValue):
++    rcode = 0
++
++    try:
++        int(sValue, 16)
++    except:
++        rcode = -1
++
++    return rcode
++
++
++#-----------------------------------------------------------
++# def CheckDigitHex()
++#
++#   Check string which is decimal or hexadecimal number
++#
++# Input:
++#   sValue : string
++# Output:
++#   int    : 10: decimal, 16: hexadecimal
++#-----------------------------------------------------------
++def CheckDigitHex(sValue):
++    rcode = 10
++
++    if len(sValue) > 2:
++      if sValue[:2] == "0x" or sValue[:2] == "0X":
++        rcode = 16
++
++    return rcode
++
+diff --git a/dnf-plugins/mkimg/ExecAndOutLog.py b/dnf-plugins/mkimg/ExecAndOutLog.py
+new file mode 100644
+index 0000000..0844de9
+--- /dev/null
++++ b/dnf-plugins/mkimg/ExecAndOutLog.py
+@@ -0,0 +1,27 @@
++#
++# Copyright (C) Fujitsu Limited 2018  All rights reserved
++#
++
++import sys, subprocess
++
++#-----------------------------------------------------------
++# def ExecAndOutLog()
++#
++#   Execuiting command and write out err-log.
++#
++# Input:
++#   sCmd   : command string
++#   fdLog  : file descriptor of Log file
++# Output:
++#   int    : return code for executing command
++#-----------------------------------------------------------
++def ExecAndOutLog(sCmd, fdLog):
++    # Execute Command
++    output = subprocess.getstatusoutput(sCmd)
++
++    # Display and Write out Standard-Error, log file
++    sys.stdout.write(output[1])
++    fdLog.write(output[1])
++
++    return output[0]
++
+diff --git a/dnf-plugins/mkimg/MKIMGINITRAMFSWindow.py b/dnf-plugins/mkimg/MKIMGINITRAMFSWindow.py
+new file mode 100644
+index 0000000..bce630f
+--- /dev/null
++++ b/dnf-plugins/mkimg/MKIMGINITRAMFSWindow.py
+@@ -0,0 +1,296 @@
++#
++# Copyright (C) Fujitsu Limited 2018 All rights reserved
++#
++
++import os
++from ..window import *
++from .ExecAndOutLog import *
++from .OpenLogFile import *
++from .ButtonErrorWindow import *
++from .MKIMGInfo import *
++
++#------------------------------------------------------------
++# def MKIMGSetupINITRAMFSWindow()
++#
++#   Display INITRAMFS Setup Window.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szFromdir    : Path of From-directory
++#    szTodir      : Path of To-directory
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#    str : fromdir
++#    str : todir
++#------------------------------------------------------------
++def MKIMGSetupINITRAMFSWindow(insScreen, szFromdir=".rootfs-x86", szTodir="rootfs.initramfs.bin"):
++    TAG_SRC_DIR    = "From directory   : "
++    TAG_TARGET_DIR = "To directory     : "
++
++    # Create Button instance
++    buttons = (("OK", "ok"), ("Back", "back"))
++    bb = snack.ButtonBar(insScreen, buttons)
++
++    # Create Grid instance
++    g = snack.GridForm(insScreen, "INITRAMFS Parameter", 1, 7)
++
++    #init snack.Grid object dict
++    sg = {}
++    for i in range(0, 2):
++        sg[i] = snack.Grid(3, 1)
++
++    # source directory
++    sg[0].setField(snack.Textbox(19, 1, TAG_SRC_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_fromdir = snack.Entry(29, szFromdir, scroll = 1)
++    sg[0].setField(txt_fromdir, 1, 0, (0, 0, 0, 0))
++    sg[0].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # target directory
++    sg[1].setField(snack.Textbox(19, 1, TAG_TARGET_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_todir = snack.Entry(29, szTodir, scroll = 1)
++    sg[1].setField(txt_todir, 1, 0, (0, 0, 0, 0))
++    sg[1].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    for i in range(0, 2):
++        g.add(sg[i], 0, i, (0, 0, 0, 0))
++
++    #Add buttons
++    g.add(bb,  0, 6, (0, 1, 0, -1))
++
++    # Display window
++    while True:
++        result = bb.buttonPressed(g.run())
++
++        if result == "ok":
++            rcode = "n"
++            break
++        elif result == "back":
++            rcode = "b"
++            break
++
++    # set From Directory
++    fromdir = txt_fromdir.value()
++    fromdir = fromdir.strip()
++
++    # set To Directory
++    todir = txt_todir.value()
++    todir = todir.strip()
++
++    insScreen.popWindow()
++    return (rcode, fromdir, todir)
++
++#------------------------------------------------------------
++# def MKIMGINITRAMFSWindowCtrl()
++#
++#   WindowCtrl for making INITRAMFS image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGINITRAMFSWindowCtrl(insScreen, insMKIMGInfo):
++
++    while True:
++        #Get the default value for INITRAMFS
++
++        szFromdir = insMKIMGInfo.get_from_dir_path()
++        szTodir = insMKIMGInfo.get_to_dir_path()
++
++        # Completion the Todir if image_file_name exists
++        if insMKIMGInfo.get_image_file_name():
++           szTodir = szTodir + "/" + insMKIMGInfo.get_image_file_name()
++
++        (rcode, szFromdir, szTodir) = \
++            MKIMGSetupINITRAMFSWindow(insScreen, szFromdir, szTodir)
++
++        #Change relative path to absolute path
++        szFromdir = os.path.abspath(szFromdir);
++        szTodir = os.path.abspath(szTodir);
++
++        insMKIMGInfo.set_from_dir_path(szFromdir)
++        insMKIMGInfo.set_to_dir_path(szTodir)
++
++        # Check input paras
++        if rcode == "n":
++            (err, err_str) = insMKIMGInfo.check_from_dir_path()
++            if err != 0:
++                item = err_str
++                ButtonErrorWindow(insScreen, item)
++                continue
++
++            else:
++                break;
++
++
++        if rcode == "b":
++            # back
++            return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmINITRAMFSWindow()
++#
++#   Display Confirm Window before making image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szFromdir    : Path of From-directory
++#    szTodir      : Path of To-directory
++#    szImgfile    : Name of Image-file
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#------------------------------------------------------------
++def MKIMGConfirmINITRAMFSWindow(insScreen, szFromdir, szTodir, szImgfile):
++    TAG_FROM_DIR    = "From directory:"
++    TAG_TO_DIR      = "To directory:"
++    TAG_IMG_TYP     = "Image type       : "
++    TAG_IMG_FILE    = "Image file name  : "
++    TAG_INDENT_SPACE= "                   "
++
++    # Create Main Text
++    (main_width, main_height) = GetButtonMainSize(insScreen)
++
++    wrapper = textwrap.TextWrapper(width = main_width - 2)
++
++    wrapper.initial_indent    = "  "
++    wrapper.subsequent_indent = "  "
++
++    lst_text = []
++
++    lst_text.append("Are you sure to start making filesystem image ?\n\n")
++
++    lst_text.append(TAG_FROM_DIR + "\n")
++    lst_text.append(wrapper.fill(szFromdir) + "\n\n")
++
++    lst_text.append(TAG_TO_DIR + "\n")
++    lst_text.append(wrapper.fill(szTodir) + "\n\n")
++
++    lst_text.append(TAG_IMG_TYP + "INITRAMFS\n")
++
++
++    wrapper.initial_indent    = TAG_IMG_FILE
++    wrapper.subsequent_indent = TAG_INDENT_SPACE
++    lst_text.append(wrapper.fill(szImgfile) + "\n")
++
++    # List To Text
++    main_text = "".join(lst_text)
++    del lst_text
++
++    # Create Button list
++    buttons = ["OK", "Back", "Exit"]
++
++    rcode = ButtonInfoWindow(insScreen, "Ready ?", main_text, \
++                              main_width, main_height, buttons)
++
++    return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmINITRAMFSWindowCtrl()
++#
++#   Confirm for making INITRAMFS image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGConfirmINITRAMFSWindowCtrl(insScreen, insMKIMGInfo):
++    # Get Parameters
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgfile = insMKIMGInfo.get_image_file_name()
++
++    while True:
++        rcode = MKIMGConfirmINITRAMFSWindow(insScreen, fromdir, todir, imgfile)
++
++        if rcode == "e":
++            # exit
++            insScreen.popHelpLine()
++            insScreen.popWindow()
++            exit_hkey = HotkeyExitWindow(insScreen)
++            if exit_hkey == "y":
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++                    sys.exit(0)
++
++        elif rcode == "o":
++            logfile = imgfile + ".log"
++            try:
++                fdLog = OpenLogFile(logfile)
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++
++                MKIMGCreateINITRAMFS(insMKIMGInfo, fdLog)
++                sys.exit(0)
++
++            finally:
++                # Log File Close
++                fdLog.close()
++                sys.exit(0)
++
++        else:
++            # back
++            return rcode
++
++#-----------------------------------------------------------
++# def MKIMGCreateINITRAMFS()
++#
++#   Create INITRAMFS image.
++#
++# Input:
++#    insMKIMGInfo : instance of class MKIMGInfo
++#    fdLog        : file descriptor of Log file
++# Output:
++#    bool         : success=True, fail=False
++#-----------------------------------------------------------
++def MKIMGCreateINITRAMFS(insMKIMGInfo, fdLog):
++
++    MSG_START        = "Making the INITRAMFS image start."
++    MSG_END_SUCCESS  = "\nMaking the INITRAMFS image succeeded."
++    MSG_END_FAILED   = "Making the INITRAMFS image failed."
++    MSG_FINISH       = "RootFS Image Maker finish."
++
++    print(MSG_START)
++    fdLog.write(MSG_START + "\n")
++
++    rcode = True
++
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgname = insMKIMGInfo.get_image_file_name()
++    imgpath = todir + "/" + imgname
++
++    # Execute Command
++    cmd = "cd \'%s\'; find . -print | cpio -o -H newc > \'%s\'" % \
++            (fromdir, imgpath)
++    if ExecAndOutLog(cmd, fdLog) != 0:
++        rcode = False
++
++    if rcode == True:
++        cmd = "gzip -9 -f \'%s\'" % imgpath
++        if ExecAndOutLog(cmd, fdLog) != 0:
++            rcode = False
++
++    if rcode == True:
++        os.chmod(todir, 0o644)
++        print(MSG_END_SUCCESS)
++        fdLog.write(MSG_END_SUCCESS + "\n")
++    else:
++        print(MSG_END_FAILED)
++        fdLog.write(MSG_END_FAILED + "\n")
++
++    print(MSG_FINISH)
++    fdLog.write(MSG_FINISH + "\n")
++
++    if rcode == True:
++        rcode = 0
++    else:
++        rcode = -1
++
++    return rcode
+diff --git a/dnf-plugins/mkimg/MKIMGINITRDWindow.py b/dnf-plugins/mkimg/MKIMGINITRDWindow.py
+new file mode 100644
+index 0000000..be92cf9
+--- /dev/null
++++ b/dnf-plugins/mkimg/MKIMGINITRDWindow.py
+@@ -0,0 +1,417 @@
++#
++# Copyright (C) Fujitsu Limited 2018 All rights reserved
++#
++
++import os
++from ..window import *
++from .ExecAndOutLog import *
++from .OpenLogFile import *
++from .ButtonErrorWindow import *
++from .MKIMGInfo import *
++
++#------------------------------------------------------------
++# def MKIMGSetupINITRDWindow()
++#
++#   Display INITRD Setup Window.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szFromdir    : Path of From-directory
++#    szTodir      : Path of To-directory
++#    szImgsize    : Image size (string)
++#    szLoopdev    : Path of Loop device (default:/dev/loop0)
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#    str : fromdir
++#    str : todir
++#    str : Image size
++#    str : Path of Loop device
++#    str : Path of Mount point
++#------------------------------------------------------------
++def MKIMGSetupINITRDWindow(insScreen, szFromdir=".rootfs-x86", szTodir="rootfs.initrd.bin", \
++                          szImgsize="10", szLoopdev="", szMountpt=""):
++    TAG_SRC_DIR     = "From directory  : "
++    TAG_TARGET_DIR  = "To directory    : "
++    TAG_IMG_SIZE    = "Image size      : "
++    TAG_LOOP_DEVICE = "Use loop device : "
++    TAG_MOUNT_POINT = "Use mount point : "
++
++    # Create Button instance
++    buttons = (("OK", "ok"), ("Back", "back"))
++    bb = snack.ButtonBar(insScreen, buttons)
++
++    # Create Grid instance
++    g = snack.GridForm(insScreen, "INITRD Parameter", 1, 7)
++
++    #init snack.Grid object dict
++    sg = {}
++    for i in range(0, 5):
++        sg[i] = snack.Grid(3, 1)
++
++    # source directory
++    sg[0].setField(snack.Textbox(19, 1, TAG_SRC_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_fromdir = snack.Entry(29, szFromdir, scroll = 1)
++    sg[0].setField(txt_fromdir, 1, 0, (0, 0, 0, 0))
++    sg[0].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # target directory
++    sg[1].setField(snack.Textbox(19, 1, TAG_TARGET_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_todir = snack.Entry(29, szTodir, scroll = 1)
++    sg[1].setField(txt_todir, 1, 0, (0, 0, 0, 0))
++    sg[1].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # Image size
++    sg[2].setField(snack.Textbox(19, 1, TAG_IMG_SIZE), \
++                        0, 0, (-12, 0, 0, 0))
++    txt_imgsize = snack.Entry(15, szImgsize, scroll = 0)
++    sg[2].setField(txt_imgsize, 1, 0, (0, 0, 0, 0))
++    sg[2].setField(snack.Textbox(5, 1, "bytes"), 2, 0, (0, 0, 0, 0))
++
++    # Loop device
++    sg[3].setField(snack.Textbox(19, 1, TAG_LOOP_DEVICE), \
++                        0, 0, (-12, 0, 0, 0))
++    txt_loopdev = snack.Entry(15, szLoopdev, scroll = 1)
++    sg[3].setField(txt_loopdev, 1, 0, (0, 0, 0, 0))
++    sg[3].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # Mount point
++    sg[4].setField(snack.Textbox(19, 1, TAG_MOUNT_POINT), \
++                        0, 0, (-12, 0, 0, 0))
++    txt_mountpt = snack.Entry(15, szMountpt, scroll = 1)
++    sg[4].setField(txt_mountpt, 1, 0, (0, 0, 0, 0))
++    sg[4].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    for i in range(0, 5):
++        g.add(sg[i], 0, i, (0, 0, 0, 0))
++
++    #Add buttons
++    g.add(bb, 0, 6, (0, 1, 0, -1))
++
++    # Display window
++    while True:
++        result = bb.buttonPressed(g.run())
++
++        if result == "ok":
++            rcode = "n"
++            break
++        elif result == "back":
++            rcode = "b"
++            break
++
++    # set From Directory
++    fromdir = txt_fromdir.value()
++    fromdir = fromdir.strip()
++
++    # set To Directory
++    todir = txt_todir.value()
++    todir = todir.strip()
++
++    # set Image size
++    imgsize = txt_imgsize.value()
++    imgsize = imgsize.strip()
++
++    # set Loop device
++    loopdev = txt_loopdev.value()
++    loopdev = loopdev.strip()
++
++    # set Mount point
++    mountpt = txt_mountpt.value()
++    mountpt = mountpt.strip()
++    insScreen.popWindow()
++    return (rcode, fromdir, todir, imgsize, loopdev, mountpt)
++
++#------------------------------------------------------------
++# def MKIMGINITRDWindowCtrl()
++#
++#   WindowCtrl for making INITRD image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGINITRDWindowCtrl(insScreen, insMKIMGInfo):
++
++    ERR_ITEM_IMAGE_SIZE  = "Image size"
++    ERR_ITEM_LOOP_DEVICE = "Use loop device"
++    ERR_ITEM_MOUNT_POINT = "Use mount point"
++
++    while True:
++        # Get the default value for INITRD
++        (szimgsize, limgsize, szloopdev, szmountpt) = \
++                               insMKIMGInfo.get_initrd_param()
++
++
++        szFromdir = insMKIMGInfo.get_from_dir_path()
++        szTodir = insMKIMGInfo.get_to_dir_path()
++
++        # Completion the Todir if image_file_name exists
++        if insMKIMGInfo.get_image_file_name():
++           szTodir = szTodir + "/" + insMKIMGInfo.get_image_file_name()
++
++        (rcode, szFromdir, szTodir, szimgsize, szloopdev, szmountpt) =\
++            MKIMGSetupINITRDWindow(insScreen, szFromdir, szTodir, szimgsize,\
++                                   szloopdev, szmountpt)
++
++        #Change relative path to absolute path
++        szFromdir = os.path.abspath(szFromdir);
++        szTodir = os.path.abspath(szTodir);
++
++        #set values for insMKIMGInfo
++        insMKIMGInfo.set_initrd_param(szimgsize, szloopdev, szmountpt)
++        insMKIMGInfo.set_from_dir_path(szFromdir)
++        insMKIMGInfo.set_to_dir_path(szTodir)
++
++        # Check input paras
++        if rcode == "n":
++            (err, err_str) = insMKIMGInfo.check_from_dir_path()
++            if err != 0:
++                item = err_str
++                ButtonErrorWindow(insScreen, item)
++                continue
++
++            err = insMKIMGInfo.check_initrd_param()
++            if err != 0:
++                item = ""
++                if err == MKIMG_LABEL_IMG_SIZE:
++                    item = ERR_ITEM_IMAGE_SIZE
++                elif err == MKIMG_LABEL_LOOP_DEV:
++                    item = ERR_ITEM_LOOP_DEVICE
++                elif err == MKIMG_LABEL_MOUNT_PT:
++                    item = ERR_ITEM_MOUNT_POINT
++                ButtonErrorWindow(insScreen, item)
++                continue
++
++            else:
++                # transfer string to long int
++                insMKIMGInfo.set_initrd_long_param()
++                break;
++
++        if rcode == "b":
++            # back
++            return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmINITRDWindow()
++#
++#   Display Confirm Window before making image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szFromdir    : Path of From-directory
++#    szTodir      : Path of To-directory
++#    szImgfile    : Name of Imgfile
++#    lImgsize     : Image size (long)
++#    szLoopdev    : Path of Loop device
++#    szMountpt    : Path of mount point
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#------------------------------------------------------------
++def MKIMGConfirmINITRDWindow(insScreen, szFromdir, szTodir, szImgfile, \
++                             lImgsize, szLoopdev, szMountpt):
++    TAG_FROM_DIR    = "From directory:"
++    TAG_TO_DIR      = "To directory:"
++    TAG_IMG_TYP     = "Image type      : "
++    TAG_IMG_FILE    = "Image file name : "
++    TAG_IMG_SIZE    = "Image size      : "
++    TAG_FILESYSTEM  = "Filesystem type : "
++    TAG_LOOP_DEVICE = "Use loop device : "
++    TAG_MOUNT_POINT = "Use mount point : "
++    TAG_INDENT_SPACE= "                  "
++
++    LBL_EXT2 = "ext2"
++
++    # Create Main Text
++    (main_width, main_height) = GetButtonMainSize(insScreen)
++
++    wrapper = textwrap.TextWrapper(width = main_width - 2)
++
++    wrapper.initial_indent    = "  "
++    wrapper.subsequent_indent = "  "
++
++    lst_text = []
++
++    lst_text.append("Are you sure to start making filesystem image ?\n\n")
++
++    if not szFromdir.startswith("/"):
++        szFromdir = os.getcwd() + '/' +szFromdir
++
++    lst_text.append(TAG_FROM_DIR + "\n")
++    lst_text.append(wrapper.fill(szFromdir) + "\n\n")
++
++    lst_text.append(TAG_TO_DIR + "\n")
++    lst_text.append(wrapper.fill(szTodir) + "\n\n")
++
++    lst_text.append(TAG_IMG_TYP + "INITRD\n")
++
++
++    wrapper.initial_indent    = TAG_IMG_FILE
++    wrapper.subsequent_indent = TAG_INDENT_SPACE
++    lst_text.append(wrapper.fill(szImgfile) + "\n")
++
++    imgsize  = "%d" % lImgsize
++    lst_text.append(TAG_IMG_SIZE   + imgsize + " bytes\n")
++    lst_text.append(TAG_FILESYSTEM + LBL_EXT2  + "\n")
++
++    wrapper.initial_indent    = TAG_LOOP_DEVICE
++    wrapper.subsequent_indent = TAG_INDENT_SPACE
++    lst_text.append(wrapper.fill(szLoopdev) + "\n")
++
++    wrapper.initial_indent    = TAG_MOUNT_POINT
++    wrapper.subsequent_indent = TAG_INDENT_SPACE
++    lst_text.append(wrapper.fill(szMountpt) + "\n")
++    # List To Text
++    main_text = "".join(lst_text)
++    del lst_text
++
++    # Create Button list
++    buttons = ["OK", "Back", "Exit"]
++
++    rcode = ButtonInfoWindow(insScreen, "Ready ?", main_text, \
++                              main_width, main_height, buttons)
++
++    return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmINITRDWindowCtrl()
++#
++#   Confirm for making INITRD image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGConfirmINITRDWindowCtrl(insScreen, insMKIMGInfo):
++    # Get Parameters
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgfile = insMKIMGInfo.get_image_file_name()
++
++    (szimgsize, limgsize, szloopdev, szmountpt) = \
++                               insMKIMGInfo.get_initrd_param()
++
++    szloopdev = os.path.abspath(szloopdev)
++    szmountpt = os.path.abspath(szmountpt)
++
++    while True:
++        rcode = MKIMGConfirmINITRDWindow(insScreen, fromdir, todir, imgfile,\
++                                         limgsize, szloopdev, szmountpt)
++
++        if rcode == "e":
++            # exit
++            insScreen.popHelpLine()
++            insScreen.popWindow()
++            exit_hkey = HotkeyExitWindow(insScreen)
++            if exit_hkey == "y":
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++                    sys.exit(0)
++
++        elif rcode == "o":
++            logfile = imgfile + ".log"
++            try:
++                fdLog = OpenLogFile(logfile)
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++
++                MKIMGCreateINITRD(insMKIMGInfo, fdLog)
++                sys.exit(0)
++
++            finally:
++                # Log File Close
++                fdLog.close()
++                sys.exit(0)
++
++        else:
++            # back
++            return rcode
++
++#-----------------------------------------------------------
++# def MKIMGCreateINITRD()
++#
++
++#   Create INITRD image.
++#
++# Input:
++#    insMKIMGInfo : instance of class MKIMGInfo
++#    fdLog        : file descriptor of Log file
++# Output:
++#    bool         : success=True, fail=False
++#-----------------------------------------------------------
++def MKIMGCreateINITRD(insMKIMGInfo, fdLog):
++
++    MSG_START        = "Making the INITRD image start."
++    MSG_END_SUCCESS  = "\nMaking the INITRD image succeeded."
++    MSG_END_FAILED   = "\nMaking the INITRD image failed."
++    MSG_FINISH       = "RootFS Image Maker finish."
++
++    print(MSG_START)
++    fdLog.write(MSG_START + "\n")
++
++    rcode = True
++
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgname = insMKIMGInfo.get_image_file_name()
++    imgpath = todir + "/" + imgname
++
++    (szimgsize, limgsize, szloop, szmountpt) = insMKIMGInfo.get_initrd_param()
++
++    szloop    = os.path.abspath(szloop)
++    szmountpt = os.path.abspath(szmountpt)
++
++    # calculate count
++    count = int(limgsize/MKIMG_BLOCK_SIZE)
++
++    # Init all cmd steps
++    cmd_steps = { 0: "dd if=/dev/zero of=\'%s\' bs=%s count=%s" %(imgpath, MKIMG_BLOCK_SIZE, count), \
++                  1: "/sbin/losetup \'%s\' \'%s\'" %(szloop, imgpath), \
++                  2: "/sbin/mkfs.ext2 \'%s\'" %szloop, \
++                  3: "mount -t ext2 \'%s\' \'%s\'" %(szloop, szmountpt), \
++                  4: "cd \'%s\'; find . -print | cpio -p \'%s\'" %(fromdir, szmountpt), \
++                  5: "umount \'%s\'" %szmountpt, \
++                  6: "/sbin/losetup -d \'%s\'" %szloop, \
++                  7: "gzip -9 -f \'%s\'" %imgpath \
++                   }
++
++    # Execute Commands
++    step = 0
++    while step < 8:
++        cmd = cmd_steps[step]
++        if ExecAndOutLog(cmd, fdLog) != 0:
++            rcode = False
++            if step == 2 or step == 3:
++                step = 6
++                continue
++            if step == 4 or step == 5:
++                step = step + 1
++                continue
++            else:
++                break
++
++        step = step + 1
++
++    if rcode == True:
++        os.chmod(imgpath, 0o644)
++        print(MSG_END_SUCCESS)
++        fdLog.write(MSG_END_SUCCESS + "\n")
++    else:
++        print(MSG_END_FAILED)
++        fdLog.write(MSG_END_FAILED + "\n")
++
++    print(MSG_FINISH)
++    fdLog.write(MSG_FINISH + "\n")
++
++    if rcode == True:
++        rcode = 0
++    else:
++        rcode = -1
++
++    return rcode
+diff --git a/dnf-plugins/mkimg/MKIMGInfo.py b/dnf-plugins/mkimg/MKIMGInfo.py
+new file mode 100644
+index 0000000..c271024
+--- /dev/null
++++ b/dnf-plugins/mkimg/MKIMGInfo.py
+@@ -0,0 +1,793 @@
++#
++# Copyright (C) Fujitsu Limited 2018 All rights reserved
++#
++
++import os
++
++#import logging, logging.handlers
++
++from ..Define import DEF_DEFAULT_LOOP_DEVICE
++from ..Define import DEF_DEFAULT_LOOP_MOUNT_POINT
++
++from .CheckString import *
++
++MKIMG_IMG_TYPE_JFFS2     = 0
++MKIMG_IMG_TYPE_INITRAMFS = 1
++MKIMG_IMG_TYPE_INITRD    = 2
++MKIMG_IMG_TYPE_RAW       = 3
++MKIMG_IMG_TYPE_SQUASHFS  = 4
++MKIMG_IMG_TYPE_UBIFS     = 5
++MKIMG_IMG_TYPE_CRAMFS    = 6
++MKIMG_IMG_TYPE_LOGFS     = 7
++
++MKIMG_LABEL_IMG_SIZE     = 1
++MKIMG_LABEL_PAGE_SIZE    = 2
++MKIMG_LABEL_ERASE_BS     = 3
++MKIMG_LABEL_LOOP_DEV     = 4
++MKIMG_LABEL_MOUNT_PT     = 5
++MKIMG_LABEL_BLK_SIZE     = 6
++MKIMG_LABEL_LEB_SIZE     = 7
++MKIMG_LABEL_MEB_SIZE     = 8
++MKIMG_LABEL_COMPRESS     = 9
++MKIMG_LABEL_SEGSHIFT     = 10
++MKIMG_LABEL_WRITESHIFT   = 11
++
++MKIMG_BLOCK_SIZE         = 512  # Block size
++
++#-----------------------------------------------------------------------------
++# class MKIMGInfo()
++#
++#   Input data information class.
++#
++# Class variable:
++#
++#   Parameters from Command line Options
++#      sFrom_dir     : Path of From-directory
++#      sTo_dir       : Path of To-directory
++#      sImg_file     : Name of Image-file
++#      iType         : Image type (0:JFFS2, 1:INITRAMFS, 2:INITRD, 3:RAW)
++#
++#   Parameters for Making JFFS2 image
++#      sJFFS2_Img_size  : Image size (string)
++#      lJFFS2_Img_size  : Image size (long)
++#      sJFFS2_Page_size : Page size (string, default:4K)
++#      lJFFS2_Page_size : Page size (long)
++#      sJFFS2_Erase_bs  : Erase block size (string)
++#      lJFFS2_Erase_bs  : Erase block size (long)
++#      iJFFS2_Endian    : Endian (0:Little endian, 1:Bigendian, default:0)
++#
++#   Parameters for Making INITRD image
++#      sINITRD_Img_size : Image size (string)
++#      lINITRD_Img_size : Image size (long)
++#      sINITRD_Loop_dev : Path of Loop device (default:/dev/loop0)
++#      sINITRD_Mount_pt : Path of Mount point (default:/mnt)
++#
++#   Parameters for Making RAW image
++#      sRAW_Img_size    : Image size (string)
++#      lRAW_Img_size    : Image size (long)
++#      sRAW_Loop_dev    : Path of Loop device (default:/dev/loop0)
++#      sRAW_Mount_pt    : Path of Mount point (default:/mnt)
++#      iRAW_Filesystem  : Filesystem (0:ext2, 1:ext3, 2:ext4, default:0)
++#
++#-----------------------------------------------------------------------------
++class MKIMGInfo:
++
++    #------------------------------------------------------------------
++    # def __init__()
++    #
++    #   MKIMGInfo class initialize.
++    #
++    # Input:
++    #   self   : my instance
++    #   sFrom  : path of From-directory
++    #   sTo    : path of To-directory
++    #   sImg   : name of Image-file
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def __init__(self, iType):
++        # Common Parameters for each image
++        self.sFrom_dir = ""
++        self.sTo_dir   = os.getcwd()
++        self.sImg_file = ""
++        self.iType      = iType
++
++        # Parameters for Making JFFS2 image
++        self.sJFFS2_Img_size  = "10M"
++        self.lJFFS2_Img_size  = 0
++        self.sJFFS2_Page_size = "4K"
++        self.lJFFS2_Page_size = 4096
++        self.sJFFS2_Erase_bs  = "64K"
++        self.lJFFS2_Erase_bs  = 0
++        self.iJFFS2_Endian    = 0
++
++        # Parameters for Making INITRD image
++        self.sINITRD_Img_size = ""
++        self.lINITRD_Img_size = 0
++        self.sINITRD_Loop_dev = DEF_DEFAULT_LOOP_DEVICE
++        self.sINITRD_Mount_pt = DEF_DEFAULT_LOOP_MOUNT_POINT
++
++        # Parameters for Making RAW image
++        self.sRAW_Img_size = ""
++        self.lRAW_Img_size = 0
++        self.sRAW_Loop_dev = DEF_DEFAULT_LOOP_DEVICE
++        self.sRAW_Mount_pt = DEF_DEFAULT_LOOP_MOUNT_POINT
++        self.iRAW_Filesystem = "ext4"
++
++        # Parameters for Squash FS Image
++        self.sSquash_Blk_size = "4K"
++        self.lSquash_Blk_size = 0
++
++        # Parameters for UBIFS Image
++        self.sUBIFS_MIN_size = ""
++        self.sUBIFS_LEB_size = ""
++        self.sUBIFS_MEB_size = ""
++        self.lUBIFS_MIN_size = 0
++        self.lUBIFS_LEB_size = 0
++        self.lUBIFS_MEB_size = 0
++
++    #=================================================================
++    # SquashFS image
++    #=================================================================
++
++    #------------------------------------------------------------------
++    # def set_squashfs_param()
++    #
++    #   Set Parameters for Making SquashFS image.
++    #
++    # Input:
++    #   self       : my instance
++    #   sSize      : block size
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_squashfs_param(self, sSize):
++        self.sSquash_Blk_size = sSize        # Block size
++
++    #------------------------------------------------------------------
++    # def set_squashfs_long_param()
++    #
++    #   Set Long Type Parameters for Making SquashFS image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_squashfs_long_param(self):
++        self.lSquash_Blk_size  = self.change_string_to_decimal(self.sSquash_Blk_size)
++
++    #------------------------------------------------------------------
++    # def get_squashfs_param()
++    #
++    #   Get Parameters for Making SquashFS image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   str        : block size
++    #   long       : block size
++    #------------------------------------------------------------------
++    def get_squashfs_param(self):
++        return (self.sSquash_Blk_size, self.lSquash_Blk_size)
++
++    #------------------------------------------------------------------
++    # def check_squashfs_param()
++    #
++    #   Check Parameters for Making SquashFS image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   int        : index of error parameter
++    #                (success=0, fail=MKIMG_LABEL_BLK_SIZE)
++    #------------------------------------------------------------------
++    def check_squashfs_param(self):
++
++        # Check Block size (Character and Size)
++        err = CheckString(self.sSquash_Blk_size)
++        if err != 0:
++            return MKIMG_LABEL_BLK_SIZE
++
++        tmp = self.sSquash_Blk_size.lower()
++        rcode = CheckDigitHex(tmp)
++
++        if rcode == 10:
++            if tmp[-1:] != "k" and tmp[-1:] != "m":
++                r = int(tmp, 10) % MKIMG_BLOCK_SIZE
++                if r != 0:
++                    return MKIMG_LABEL_BLK_SIZE
++        elif rcode == 16:
++            r = int(tmp, 16) % MKIMG_BLOCK_SIZE
++            if r != 0:
++                return MKIMG_LABEL_BLK_SIZE
++
++        return 0
++
++    #=================================================================
++    # UBIFS image
++    #=================================================================
++
++    #------------------------------------------------------------------
++    # def set_ubifs_param()
++    #
++    #   Set Parameters for Making UBIFS image.
++    #
++    # Input:
++    #   self       : my instance
++    #   sMin_size  : min size
++    #   sLEB_size  : logical erase block size
++    #   sMEB_size  : maximam erase block size
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_ubifs_param(self, sMin_size, sLEB_size, sMEB_size):
++        self.sUBIFS_MIN_size = sMin_size
++        self.sUBIFS_LEB_size = sLEB_size
++        self.sUBIFS_MEB_size = sMEB_size
++
++    #------------------------------------------------------------------
++    # def set_ubifs_long_param()
++    #
++    #   Set Long Type Parameters for Making UBIFS image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_ubifs_long_param(self):
++        self.lUBIFS_MIN_size = self.change_string_to_decimal(self.sUBIFS_MIN_size)
++        self.lUBIFS_LEB_size = self.change_string_to_decimal(self.sUBIFS_LEB_size)
++        self.lUBIFS_MEB_size = self.change_string_to_decimal(self.sUBIFS_MEB_size)
++
++    #------------------------------------------------------------------
++    # def get_ubifs_param()
++    #
++    #   Get Parameters for Making UBIFS image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   str        : min size
++    #   long       : min size
++    #   str        : logical erase block size
++    #   long       : logical erase block size
++    #   str        : maximam erase block size
++    #   long       : maximam erase block size
++    #------------------------------------------------------------------
++    def get_ubifs_param(self):
++        return (self.sUBIFS_MIN_size, self.lUBIFS_MIN_size, \
++                self.sUBIFS_LEB_size, self.lUBIFS_LEB_size, \
++                self.sUBIFS_MEB_size, self.lUBIFS_MEB_size )
++
++    #------------------------------------------------------------------
++    # def check_ubifs_param()
++    #
++    #   Check Parameters for Making UBIFS image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   int        : index of error parameter
++    #                (success=0, fail=MKIMG_LABEL_BLK_SIZE)
++    #------------------------------------------------------------------
++    def check_ubifs_param(self):
++
++        # Check Block size (Character and Size)
++        err = CheckString(self.sUBIFS_MIN_size)
++        if err != 0:
++            return MKIMG_LABEL_BLK_SIZE
++
++        # Check LEB size (Character and Size)
++        err = CheckString(self.sUBIFS_LEB_size)
++        if err != 0:
++            return MKIMG_LABEL_LEB_SIZE
++
++        # Check MEB size (Character and Size)
++        err = CheckString(self.sUBIFS_MEB_size)
++        if err != 0:
++            return MKIMG_LABEL_MEB_SIZE
++
++        return 0
++
++
++    #=================================================================
++    # Common Parameters
++    #=================================================================
++
++    #------------------------------------------------------------------
++    # def set_from_dir_path()
++    #
++    #   Set path of From-directory.
++    #
++    # Input:
++    #   self       : my instance
++    #   sFrom_dir  : path of From-directory
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_from_dir_path(self, sFrom_dir):
++        self.sFrom_dir = sFrom_dir
++
++
++    #------------------------------------------------------------------
++    # def get_from_dir_path()
++    #
++    #   Get path of From-directory.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   str        : path of From-directory
++    #------------------------------------------------------------------
++    def get_from_dir_path(self):
++        return self.sFrom_dir
++
++
++    #------------------------------------------------------------------
++    # def get_from_dir_path()
++    #
++    #   Get path of From-directory.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   int        : err code
++    #   str        : err message of From-directory
++    #------------------------------------------------------------------
++    def check_from_dir_path(self):
++        # Check From Directory
++        # From-directory path does not exist ?
++        if not os.path.exists(self.sFrom_dir):
++            err_str = "%s: From-directory does not exist" % self.sFrom_dir
++            return (-1, err_str)
++
++        # From-directory path is not directory ?
++        if not os.path.isdir(self.sFrom_dir):
++            err_str = "%s: From-directory path is not directory" % self.sFrom_dir
++            return (-1, err_str)
++
++        # From-directory is empty ?
++        list = os.listdir(self.sFrom_dir)
++        if len(list) == 0:
++            err_str = "%s: From-directory is empty" % self.sFrom_dir
++            return (-1, err_str)
++        del list
++
++        return (0, "")
++
++    #------------------------------------------------------------------
++    # def set_to_dir_path()
++    #
++    #   Set path of To-directory.
++    #
++    # Input:
++    #   self       : my instance
++    #   sTo_dir    : path of To-directory
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_to_dir_path(self, sTo_dir):
++        self.sTo_dir = sTo_dir
++
++
++    #------------------------------------------------------------------
++    # def get_to_dir_path()
++    #
++    #   Get path of To-directory.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   str        : path of To-directory
++    #------------------------------------------------------------------
++    def get_to_dir_path(self):
++        return self.sTo_dir
++
++
++    #------------------------------------------------------------------
++    # def set_image_file_name()
++    #
++    #   Set name of Image-file.
++    #
++    # Input:
++    #   self       : my instance
++    #   sImg_file  : name of Image-file
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_image_file_name(self, sImg_file):
++        self.sImg_file = sImg_file
++
++
++    #------------------------------------------------------------------
++    # def get_to_dir_path()
++    #
++    #   Get name of Image-file.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   str        : name of Image-file
++    #------------------------------------------------------------------
++    def get_image_file_name(self):
++        return self.sImg_file
++
++
++    #------------------------------------------------------------------
++    # def set_image_type()
++    #
++    #   Set Image type.
++    #
++    # Input:
++    #   self       : my instance
++    #   iType      : image type number
++    #                (0:JFFS2, 1:INITRAMFS, 2:INITRD, 3:RAW)
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_image_type(self, iType):
++        self.iType = iType
++
++
++    #------------------------------------------------------------------
++    # def get_image_type()
++    #
++    #   Get Image type.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   int        : image type number
++    #                (0:JFFS2, 1:INITRAMFS, 2:INITRD, 3:RAW)
++    #------------------------------------------------------------------
++    def get_image_type(self):
++        return self.iType
++
++
++    #=================================================================
++    # JFFS2 image
++    #=================================================================
++
++    #------------------------------------------------------------------
++    # def set_jffs2_param()
++    #
++    #   Set Parameters for Making JFF2 image.
++    #
++    # Input:
++    #   self       : my instance
++    #   sSize      : image size
++    #   sPage      : page size
++    #   sErase     : erase block size
++    #   iEndian    : endian
++    #                (0:Little endian, 1:Bigendian)
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_jffs2_param(self, sSize, sPage, sErase, iEndian):
++        self.sJFFS2_Img_size  = sSize    # Image size
++        self.sJFFS2_Page_size = sPage    # Page size (default:4K)
++        self.sJFFS2_Erase_bs  = sErase   # Erase block size
++        self.iJFFS2_Endian    = iEndian  # Endian (0:Little, 1:Big)
++
++    #------------------------------------------------------------------
++    # def set_jffs2_long_param()
++    #
++    #   Set Long Type Parameters for Making JFF2 image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_jffs2_long_param(self):
++        self.lJFFS2_Img_size  = self.change_string_to_decimal(self.sJFFS2_Img_size)
++        self.lJFFS2_Page_size = self.change_string_to_decimal(self.sJFFS2_Page_size)
++        self.lJFFS2_Erase_bs  = self.change_string_to_decimal(self.sJFFS2_Erase_bs)
++
++    #------------------------------------------------------------------
++    # def get_jffs2_param()
++    #
++    #   Get Parameters for Making JFF2 image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   str        : image size
++    #   long       : image size
++    #   str        : page size
++    #   long       : page size
++    #   str        : erase block size
++    #   long       : erase block size
++    #   int        : endian
++    #                (0:Little endian, 1:Bigendian)
++    #------------------------------------------------------------------
++    def get_jffs2_param(self):
++        return (self.sJFFS2_Img_size,  self.lJFFS2_Img_size, \
++                self.sJFFS2_Page_size, self.lJFFS2_Page_size, \
++                self.sJFFS2_Erase_bs,  self.lJFFS2_Erase_bs, \
++                self.iJFFS2_Endian)
++
++
++    #------------------------------------------------------------------
++    # def check_jffs2_param()
++    #
++    #   Check Parameters for Making JFF2 image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   int        : index of error parameter
++    #                (success=0, fail=MKIMG_LABEL_IMG_SIZE,
++    #                                 MKIMG_LABEL_PAGE_SIZE,
++    #                                 MKIMG_LABEL_ERASE_BS)
++    #------------------------------------------------------------------
++    def check_jffs2_param(self):
++
++        # Check Image size (Character and Size)
++        err = CheckString(self.sJFFS2_Img_size)
++        if err != 0:
++            return MKIMG_LABEL_IMG_SIZE
++
++        tmp = self.sJFFS2_Img_size.lower()
++        rcode = CheckDigitHex(tmp)
++
++        if rcode == 10:
++            if tmp[-1:] != "k" and tmp[-1:] != "m":
++                r = int(tmp, 10) % MKIMG_BLOCK_SIZE
++                if r != 0:
++                    return MKIMG_LABEL_IMG_SIZE
++        elif rcode == 16:
++            r = int(tmp, 16) % MKIMG_BLOCK_SIZE
++            if r != 0:
++                return MKIMG_LABEL_IMG_SIZE
++
++        # Check Page size (Character)
++        err = CheckString(self.sJFFS2_Page_size)
++        if err != 0:
++            return MKIMG_LABEL_PAGE_SIZE
++
++        # Check Erase block size (Character)
++        err = CheckString(self.sJFFS2_Erase_bs)
++        if err != 0:
++            return MKIMG_LABEL_ERASE_BS
++
++        return 0
++
++
++    #=================================================================
++    # INITRD image
++    #=================================================================
++
++    #------------------------------------------------------------------
++    # def set_initrd_param()
++    #
++    #   Set Parameters for Making INITRD image.
++    #
++    # Input:
++    #   self       : my instance
++    #   sSize      : image size
++    #   sLoop      : path of loop device
++    #   sMount     : path of mount point
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_initrd_param(self, sSize, sLoop, sMount):
++        self.sINITRD_Img_size = sSize   # Image size
++        self.sINITRD_Loop_dev = sLoop   # Path of Loop device
++        self.sINITRD_Mount_pt = sMount  # Path of Mount point
++
++
++    #------------------------------------------------------------------
++    # def set_initrd_long_param()
++    #
++    #   Set Long Type Parameters for Making INITRD image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_initrd_long_param(self):
++        self.lINITRD_Img_size  = self.change_string_to_decimal(self.sINITRD_Img_size)
++
++
++    #------------------------------------------------------------------
++    # def get_initrd_param()
++    #
++    #   Get Parameters for Making INITRD image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   str        : image size
++    #   long       : image size
++    #   str        : path of loop device
++    #   str        : path of mount point
++    #------------------------------------------------------------------
++    def get_initrd_param(self):
++        return (self.sINITRD_Img_size, self.lINITRD_Img_size, \
++                self.sINITRD_Loop_dev, self.sINITRD_Mount_pt)
++
++
++    #------------------------------------------------------------------
++    # def check_initrd_param()
++    #
++    #   Check Parameters for Making INITRD image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   int        : index of error parameter
++    #                (success=0, fail=MKIMG_LABEL_IMG_SIZE,
++    #                                 MKIMG_LABEL_LOOP_DEV,
++    #                                 MKIMG_LABEL_MOUNT_PT)
++    #------------------------------------------------------------------
++    def check_initrd_param(self):
++
++        # Check Image size (Character and Size)
++        err = CheckString(self.sINITRD_Img_size)
++        if err != 0:
++            return MKIMG_LABEL_IMG_SIZE
++
++        tmp = self.sINITRD_Img_size.lower()
++        rcode = CheckDigitHex(tmp)
++
++        if rcode == 10:
++            if tmp[-1:] != "k" and tmp[-1:] != "m":
++                r = int(tmp, 10) % MKIMG_BLOCK_SIZE
++                if r != 0:
++                    return MKIMG_LABEL_IMG_SIZE
++        elif rcode == 16:
++            r = int(tmp, 16) % MKIMG_BLOCK_SIZE
++            if r != 0:
++                return MKIMG_LABEL_IMG_SIZE
++
++        # Check Loop device (exist)
++        if not os.path.exists(self.sINITRD_Loop_dev):
++            return MKIMG_LABEL_LOOP_DEV
++
++        # Check Mount point (dir)
++        if not os.path.isdir(self.sINITRD_Mount_pt):
++            return MKIMG_LABEL_MOUNT_PT
++
++        return 0
++
++
++    #=================================================================
++    # RAW image
++    #=================================================================
++
++    #------------------------------------------------------------------
++    # def set_raw_param()
++    #
++    #   Set Parameters for Making RAW image.
++    #
++    # Input:
++    #   self       : my instance
++    #   sSize      : image size
++    #   sLoop      : path of loop device
++    #   sMount     : path of mount point
++    #   iFilesystem: filesystem
++    #                (0:ext2, 1:ext3, 2:ext4)
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_raw_param(self, sSize, sLoop, sMount, iFilesystem):
++        self.sRAW_Img_size = sSize           # Image size
++        self.sRAW_Loop_dev = sLoop           # Path of Loop device
++        self.sRAW_Mount_pt = sMount          # Path of Mount point
++        self.iRAW_Filesystem  = iFilesystem  # Filesystem (0:ext2, 1:ext3, 2:ext4)
++
++
++    #------------------------------------------------------------------
++    # def set_raw_long_param()
++    #
++    #   Set Long Type Parameters for Making RAW image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   None
++    #------------------------------------------------------------------
++    def set_raw_long_param(self):
++        self.lRAW_Img_size  = self.change_string_to_decimal(self.sRAW_Img_size)
++
++
++    #------------------------------------------------------------------
++    # def get_raw_param()
++    #
++    #   Get Parameters for Making RAW image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   str        : image size
++    #   long       : image size
++    #   str        : path of loop device
++    #   str        : path of mount point
++    #   int        : filesystem
++    #                (0:ext2, 1:ext3, 2:ext4)
++    #------------------------------------------------------------------
++    def get_raw_param(self):
++        return (self.sRAW_Img_size, self.lRAW_Img_size, \
++                self.sRAW_Loop_dev, self.sRAW_Mount_pt, self.iRAW_Filesystem)
++
++
++    #------------------------------------------------------------------
++    # def check_raw_param()
++    #
++    #   Check Parameters for Making RAW image.
++    #
++    # Input:
++    #   self       : my instance
++    # Output:
++    #   int        : index of error parameter
++    #                (success=0, fail=MKIMG_LABEL_IMG_SIZE,
++    #                                 MKIMG_LABEL_LOOP_DEV,
++    #                                 MKIMG_LABEL_MOUNT_PT)
++    #------------------------------------------------------------------
++    def check_raw_param(self):
++
++        # Check Image size (Character and Size)
++        err = CheckString(self.sRAW_Img_size)
++        if err != 0:
++            return MKIMG_LABEL_IMG_SIZE
++
++        tmp = self.sRAW_Img_size.lower()
++        rcode = CheckDigitHex(tmp)
++
++        if rcode == 10:
++            if tmp[-1:] != "k" and tmp[-1:] != "m":
++                r = int(tmp, 10) % MKIMG_BLOCK_SIZE
++                if r != 0:
++                    return MKIMG_LABEL_IMG_SIZE
++        elif rcode == 16:
++            r = int(tmp, 16) % MKIMG_BLOCK_SIZE
++            if r != 0:
++                return MKIMG_LABEL_IMG_SIZE
++
++        # Check Loop device (exist)
++        if not os.path.exists(self.sRAW_Loop_dev):
++            return MKIMG_LABEL_LOOP_DEV
++
++        # Check Mount point (dir)
++        if not os.path.isdir(self.sRAW_Mount_pt):
++            return MKIMG_LABEL_MOUNT_PT
++
++        return 0
++
++    #=================================================================
++    # Common Module
++    #=================================================================
++
++    #------------------------------------------------------------------
++    # def change_string_to_decimal()
++    #
++    #   Change String Parameter to decimal.
++    #
++    # Input:
++    #   self       : my instance
++    #   sSize      : string
++    # Output:
++    #   long       : decimal number
++    #------------------------------------------------------------------
++    def change_string_to_decimal(self, sSize):
++        tmp = sSize.lower()
++
++        code = CheckDigitHex(tmp)
++
++        if code == 10:
++            if tmp[-1:] == "m":
++                size = int(tmp[:-1]) * 1024 * 1024
++            elif tmp[-1:] == "k":
++                size = int(tmp[:-1]) * 1024
++            else:
++                size = int(tmp, 10)
++        elif code == 16:
++            size = int(tmp, 16)
++
++        return size
++
++
+diff --git a/dnf-plugins/mkimg/MKIMGJFFS2Window.py b/dnf-plugins/mkimg/MKIMGJFFS2Window.py
+new file mode 100644
+index 0000000..1a49a8c
+--- /dev/null
++++ b/dnf-plugins/mkimg/MKIMGJFFS2Window.py
+@@ -0,0 +1,423 @@
++#
++# Copyright (C) Fujitsu Limited 2018 All rights reserved
++#
++
++import os
++from ..window import *
++from .ExecAndOutLog import *
++from .OpenLogFile import *
++from .ButtonErrorWindow import *
++from .MKIMGInfo import *
++
++#------------------------------------------------------------
++# def MKIMGSetupJFFS2Window()
++#
++#   Display JFFS2 Setup Window.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szImgsize    : Image size (string)
++#    szPagesize   : Page size (string)
++#    szErasebs    : Erase block size (string)
++#    iEndian      : Endian (0:Little endian, 1:Big endian, default:0)
++#    szFromdir    : Path of From-directory
++#    szTodir      : Path of To-directory
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#    str : Image size
++#    str : Page size
++#    str : Erase block size
++#    0,1 : Endian (0:Little endian, 1:Big endian, default:0)
++#    str : fromdir
++#    str : todir
++#------------------------------------------------------------
++def MKIMGSetupJFFS2Window(insScreen, szImgsize="0", szPagesize="4096",\
++                          szErasebs="16", iEndian=0, szFromdir="", szTodir="rootfs.jffs2.bin"):
++    TAG_SRC_DIR    = "From directory   : "
++    TAG_TARGET_DIR = "To directory     : "
++    TAG_IMG_NAME   = "Image file name  : "
++    TAG_IMG_SIZE   = "Image size       : "
++    TAG_PAGE_SIZE  = "Page size        : "
++    TAG_ERASE_BS   = "Erase block size : "
++    TAG_ENDIAN     = "Endian(Default is little) : "
++
++    LBL_LITTLE = "Little endian"
++    LBL_BIG    = "Big endian"
++
++    # Create Button instance
++    buttons = (("OK", "ok"), ("Back", "back"))
++    bb = snack.ButtonBar(insScreen, buttons)
++
++    # Create Grid instance
++    g = snack.GridForm(insScreen, "JFFS2 Parameter", 1, 7)
++
++    #init snack.Grid object dict
++    sg = {}
++    for i in range(0, 6):
++        sg[i] = snack.Grid(3, 1)
++
++    # source directory
++    sg[0].setField(snack.Textbox(19, 1, TAG_SRC_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_fromdir = snack.Entry(29, szFromdir, scroll = 1)
++    sg[0].setField(txt_fromdir, 1, 0, (0, 0, 0, 0))
++    sg[0].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # target directory
++    sg[1].setField(snack.Textbox(19, 1, TAG_TARGET_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_todir = snack.Entry(29, szTodir, scroll = 1)
++    sg[1].setField(txt_todir, 1, 0, (0, 0, 0, 0))
++    sg[1].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # Image size
++    sg[2].setField(snack.Textbox(19, 1, TAG_IMG_SIZE), \
++                        0, 0, (-14, 0, 0, 0))
++    txt_imgsize = snack.Entry(12, szImgsize, scroll = 0)
++    sg[2].setField(txt_imgsize, 1, 0, (0, 0, 0, 0))
++    sg[2].setField(snack.Textbox(5, 1, "bytes"), 2, 0, (0, 0, 0, 0))
++
++
++    # Page size
++    sg[3].setField(snack.Textbox(19, 1, TAG_PAGE_SIZE), \
++                        0, 0, (-14, 0, 0, 0))
++    txt_pagesize = snack.Entry(12, szPagesize, scroll = 0)
++    sg[3].setField(txt_pagesize, 1, 0, (0, 0, 0, 0))
++    sg[3].setField(snack.Textbox(5, 1, "bytes"), 2, 0, (0, 0, 0, 0))
++
++
++    # Erase block size
++    sg[4].setField(snack.Textbox(19, 1, TAG_ERASE_BS), 0, 0, (-14, 0, 0, 0))
++    txt_erasebs = snack.Entry(12, szErasebs, scroll = 0)
++    sg[4].setField(txt_erasebs, 1, 0, (0, 0, 0, 0))
++    sg[4].setField(snack.Textbox(5, 1, "bytes"), 2, 0, (0, 0, 0, 0))
++
++
++    # Endian
++    sg[5].setField(snack.Textbox(29, 1, TAG_ENDIAN), 0, 0, (-7, 0, 0, 0))
++
++    cb_endian1 = snack.Checkbox(LBL_BIG, isOn = iEndian)
++    sg[5].setField(cb_endian1, 2, 0, (0, 0, 0, 0))
++
++    for i in range(0, 6):
++        g.add(sg[i], 0, i, (0, 0, 0, 0))
++
++    #Add buttons
++    g.add(bb,  0, 6, (0, 1, 0, -1))
++
++    # Display window
++    while True:
++        result = bb.buttonPressed(g.run())
++
++        if result == "ok":
++            rcode = "n"
++            break
++        elif result == "back":
++            rcode = "b"
++            break
++
++    # set From Directory
++    fromdir = txt_fromdir.value()
++    fromdir = fromdir.strip()
++
++    # set To Directory
++    todir = txt_todir.value()
++    todir = todir.strip()
++
++    # set Image size
++    imgsize = txt_imgsize.value()
++    imgsize = imgsize.strip()
++
++    # set Page size
++    pagesize = txt_pagesize.value()
++    pagesize = pagesize.strip()
++
++    # set Erase block size
++    erasebs = txt_erasebs.value()
++    erasebs = erasebs.strip()
++
++    # set Endian
++    if cb_endian1.selected():
++        endian = 1  #Big endian
++    else:
++        endian = 0  #Little endian
++
++    insScreen.popWindow()
++    return (rcode, imgsize, pagesize, erasebs, endian, fromdir, todir)
++
++#------------------------------------------------------------
++# def MKIMGJFFS2WindowCtrl()
++#
++#   WindowCtrl for making JFFS2 image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGJFFS2WindowCtrl(insScreen, insMKIMGInfo):
++
++    ERR_ITEM_IMAGE_SIZE = "Image size"
++    ERR_ITEM_PAGE_SIZE  = "Page size"
++    ERR_ITEM_ERASE_BS   = "Erase block size"
++
++    while True:
++        # Get the default value for JFFS2
++        (szimgsize, limgsize, szpagesize, lpagesize, szerasebs, \
++         lerasebs, iendian) = insMKIMGInfo.get_jffs2_param()
++
++        szFromdir = insMKIMGInfo.get_from_dir_path()
++        szTodir = insMKIMGInfo.get_to_dir_path()
++
++        # Completion the Todir if image_file_name exists
++        if insMKIMGInfo.get_image_file_name():
++           szTodir = szTodir + "/" + insMKIMGInfo.get_image_file_name()
++
++        (rcode, szimgsize, szpagesize, szerasebs, iendian, szFromdir, szTodir) = \
++            MKIMGSetupJFFS2Window(insScreen, szimgsize, szpagesize,\
++                                  szerasebs, iendian, szFromdir, szTodir)
++
++        #Change relative path to absolute path
++        szFromdir = os.path.abspath(szFromdir);
++        szTodir = os.path.abspath(szTodir);
++
++        insMKIMGInfo.set_jffs2_param(szimgsize, szpagesize, szerasebs, iendian)
++        insMKIMGInfo.set_from_dir_path(szFromdir)
++        insMKIMGInfo.set_to_dir_path(szTodir)
++
++        # Check input paras
++        if rcode == "n":
++            (err, err_str) = insMKIMGInfo.check_from_dir_path()
++            if err != 0:
++                item = err_str
++                ButtonErrorWindow(insScreen, item)
++                continue
++
++            err = insMKIMGInfo.check_jffs2_param()
++            if err != 0:
++                item = ""
++                if err == MKIMG_LABEL_IMG_SIZE:
++                    item = ERR_ITEM_IMAGE_SIZE
++                elif err == MKIMG_LABEL_PAGE_SIZE:
++                    item = ERR_ITEM_PAGE_SIZE
++                elif err == MKIMG_LABEL_ERASE_BS:
++                    item = ERR_ITEM_ERASE_BS
++                ButtonErrorWindow(insScreen, item)
++                continue
++
++            else:
++                # transfer string to long int
++                insMKIMGInfo.set_jffs2_long_param()
++                break;
++
++        if rcode == "b":
++            # back
++            return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmJFFS2Window()
++#
++#   Display Confirm Window before making image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szFromdir    : Path of From-directory
++#    szTodir      : Path of To-directory
++#    szImgfile    : Name of Imgfile
++#    lImgsize     : Image size (long)
++#    lPagesize    : Page size (long)
++#    lErasebs     : Erase block size (long)
++#    iEndian      : Endian (0:Little endian, 1:Bigendian, default:0)
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#------------------------------------------------------------
++def MKIMGConfirmJFFS2Window(insScreen, szFromdir, szTodir, szImgfile, \
++                            lImgsize, lPagesize, lErasebs, iEndian):
++    TAG_FROM_DIR    = "From directory:"
++    TAG_TO_DIR      = "To directory:"
++    TAG_IMG_TYP     = "Image type       : "
++    TAG_IMG_FILE    = "Image file name  : "
++    TAG_IMG_SIZE    = "Image size       : "
++    TAG_PAGE_SIZE   = "Page size        : "
++    TAG_ERASE_BS    = "Erase block size : "
++    TAG_ENDIAN      = "Endian           : "
++    TAG_INDENT_SPACE= "                   "
++
++    LBL_LITTLE = "Little endian"
++    LBL_BIG    = "Big endian"
++
++    #szTodir, szImgfile = os.path.split(szTodir)
++
++    # Create Main Text
++    (main_width, main_height) = GetButtonMainSize(insScreen)
++
++    wrapper = textwrap.TextWrapper(width = main_width - 2)
++
++    wrapper.initial_indent    = "  "
++    wrapper.subsequent_indent = "  "
++
++    lst_text = []
++
++    lst_text.append("Are you sure to start making filesystem image ?\n\n")
++
++
++    lst_text.append(TAG_FROM_DIR + "\n")
++    lst_text.append(wrapper.fill(szFromdir) + "\n\n")
++
++    lst_text.append(TAG_TO_DIR + "\n")
++    lst_text.append(wrapper.fill(szTodir) + "\n\n")
++
++    lst_text.append(TAG_IMG_TYP + "JFFS2\n")
++
++
++    wrapper.initial_indent    = TAG_IMG_FILE
++    wrapper.subsequent_indent = TAG_INDENT_SPACE
++    lst_text.append(wrapper.fill(szImgfile) + "\n")
++
++    imgsize  = "%d" % lImgsize
++    pagesize = "%d" % lPagesize
++    erasebs  = "%d" % lErasebs
++    lst_text.append(TAG_IMG_SIZE  + imgsize  + " bytes\n")
++    lst_text.append(TAG_PAGE_SIZE + pagesize + " bytes\n")
++    lst_text.append(TAG_ERASE_BS  + erasebs  + " bytes\n")
++
++    if iEndian == 0:
++        endian = LBL_LITTLE
++    else:
++        endian = LBL_BIG
++    lst_text.append(TAG_ENDIAN + endian + "\n")
++
++    # List To Text
++    main_text = "".join(lst_text)
++    del lst_text
++
++    # Create Button list
++    buttons = ["OK", "Back", "Exit"]
++
++    rcode = ButtonInfoWindow(insScreen, "Ready ?", main_text, \
++                              main_width, main_height, buttons)
++
++    return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmJFFS2WindowCtrl()
++#
++#   Confirm for making JFFS2 image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGConfirmJFFS2WindowCtrl(insScreen, insMKIMGInfo):
++    # Get Parameters
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgfile = insMKIMGInfo.get_image_file_name()
++
++    (szimgsize, limgsize, szpagesize, lpagesize, szerasebs, \
++     lerasebs, iendian) = insMKIMGInfo.get_jffs2_param()
++
++    while True:
++        rcode = MKIMGConfirmJFFS2Window(insScreen, fromdir, todir, imgfile, \
++                                        limgsize, lpagesize, lerasebs, iendian)
++
++        if rcode == "e":
++            # exit
++            insScreen.popHelpLine()
++            insScreen.popWindow()
++            exit_hkey = HotkeyExitWindow(insScreen)
++            if exit_hkey == "y":
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++                    sys.exit(0)
++
++        elif rcode == "o":
++            logfile = imgfile + ".log"
++            try:
++                fdLog = OpenLogFile(logfile)
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++
++                MKIMGCreateJFFS2(insMKIMGInfo, fdLog)
++                sys.exit(0)
++
++            finally:
++                # Log File Close
++                fdLog.close()
++                sys.exit(0)
++
++        else:
++            # back
++            return rcode
++
++#-----------------------------------------------------------
++# def MKIMGCreateJFFS2()
++#
++#   Create JFFS2 image.
++#
++# Input:
++#    insMKIMGInfo : instance of class MKIMGInfo
++#    fdLog        : file descriptor of Log file
++# Output:
++#    bool         : success=True, fail=False
++#-----------------------------------------------------------
++def MKIMGCreateJFFS2(insMKIMGInfo, fdLog):
++
++    MSG_START        = "Making the JFFS2 image start."
++    MSG_END_SUCCESS  = "Making the JFFS2 image succeeded."
++    MSG_END_FAILED   = "Making the JFFS2 image failed."
++    MSG_FINISH       = "RootFS Image Maker finish."
++    ERR_MSG_CREATE_SIZE = "WARNING: The image file size is larger than the specified size !!"
++
++    print(MSG_START)
++    fdLog.write(MSG_START + "\n")
++
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgname = insMKIMGInfo.get_image_file_name()
++    imgpath = todir + "/" + imgname
++
++    (szimgsize, limgsize, szpagesize, lpagesize, szerasebs, \
++     lerasebs, endian) = insMKIMGInfo.get_jffs2_param()
++
++    rcode = True
++
++    if endian == 0:
++        endian_op = "l"
++    else:
++        endian_op = "b"
++
++    # Execute Command
++    cmd = "mkfs.jffs2 -d '%s' -s %d -o \'%s\' -p %d -e %d -n -%s" % \
++         (fromdir, \
++          lpagesize, \
++          imgpath, \
++          limgsize, \
++          lerasebs, \
++          endian_op)
++
++    if ExecAndOutLog(cmd, fdLog) != 0:
++        rcode = False
++
++    if rcode == True:
++        os.chmod(todir, 0o644)
++        print(MSG_END_SUCCESS)
++        fdLog.write(MSG_END_SUCCESS + "\n")
++    else:
++        print(MSG_END_FAILED)
++        fdLog.write(MSG_END_FAILED + "\n")
++
++    print(MSG_FINISH)
++    fdLog.write(MSG_FINISH + "\n")
++
++    if rcode == True:
++        rcode = 0
++    else:
++        rcode = -1
++
++    return rcode
+diff --git a/dnf-plugins/mkimg/MKIMGRAWWindow.py b/dnf-plugins/mkimg/MKIMGRAWWindow.py
+new file mode 100755
+index 0000000..6f6f1b5
+--- /dev/null
++++ b/dnf-plugins/mkimg/MKIMGRAWWindow.py
+@@ -0,0 +1,425 @@
++#
++# Copyright (C) Fujitsu Limited 2018 All rights reserved
++#
++
++import os
++from ..window import *
++from .ExecAndOutLog import *
++from .OpenLogFile import *
++from .ButtonErrorWindow import *
++from .MKIMGInfo import *
++
++#------------------------------------------------------------
++# def MKIMGSetupRAWWindow()
++#
++#   Display RAW Setup Window.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szFromdir    : Path of From-directory
++#    szTodir      : Path of To-directory
++#    szImgsize    : Image size (string)
++#    szLoopdev    : Path of Loop device (default:/dev/loop0)
++#    szMountpt    : Path of Mount point (default:/mnt)
++#    iFilesystem  : Filesystem (The same as host)
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#    str : fromdir
++#    str : todir
++#    str : Image size
++#    str : Path of Loop device
++#    str : Path of Mount point
++#    str : Filesystem (The same as host)
++#------------------------------------------------------------
++def MKIMGSetupRAWWindow(insScreen, szFromdir=".rootfs-x86", szTodir="rootfs.raw.bin", \
++                        szImgsize="10", szLoopdev="", szMountpt="", iFilesystem="ext4"):
++    TAG_SRC_DIR     = "From directory  : "
++    TAG_TARGET_DIR  = "To directory    : "
++    TAG_FILESYSTEM  = "Filesystem type : "
++    TAG_IMG_SIZE    = "Image size      : "
++    TAG_LOOP_DEVICE = "Use loop device : "
++    TAG_MOUNT_POINT = "Use mount point : "
++
++    # Create Button instance
++    buttons = (("OK", "ok"), ("Back", "back"))
++    bb = snack.ButtonBar(insScreen, buttons)
++
++    # Create Grid instance
++    g = snack.GridForm(insScreen, "RAW Parameter", 1, 7)
++
++    #init snack.Grid object dict
++    sg = {}
++    for i in range(0, 6):
++        sg[i] = snack.Grid(3, 1)
++
++    # source directory
++    sg[0].setField(snack.Textbox(19, 1, TAG_SRC_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_fromdir = snack.Entry(29, szFromdir, scroll = 1)
++    sg[0].setField(txt_fromdir, 1, 0, (0, 0, 0, 0))
++    sg[0].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # target directory
++    sg[1].setField(snack.Textbox(19, 1, TAG_TARGET_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_todir = snack.Entry(29, szTodir, scroll = 1)
++    sg[1].setField(txt_todir, 1, 0, (0, 0, 0, 0))
++    sg[1].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # Filesystem
++    sg[2].setField(snack.Textbox(19, 1, TAG_FILESYSTEM), \
++                        0, 0, (-12, 0, 0, 0))
++    txt_filesystem = snack.Entry(15, iFilesystem, scroll = 0)
++    sg[2].setField(txt_filesystem, 1, 0, (0, 0, 0, 0))
++    sg[2].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # Image size
++    sg[3].setField(snack.Textbox(19, 1, TAG_IMG_SIZE), \
++                        0, 0, (-12, 0, 0, 0))
++    txt_imgsize = snack.Entry(15, szImgsize, scroll = 0)
++    sg[3].setField(txt_imgsize, 1, 0, (0, 0, 0, 0))
++    sg[3].setField(snack.Textbox(5, 1, "bytes"), 2, 0, (0, 0, 0, 0))
++
++    # Loop device
++    sg[4].setField(snack.Textbox(19, 1, TAG_LOOP_DEVICE), \
++                        0, 0, (-12, 0, 0, 0))
++    txt_loopdev = snack.Entry(15, szLoopdev, scroll = 0)
++    sg[4].setField(txt_loopdev, 1, 0, (0, 0, 0, 0))
++    sg[4].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # Mount point
++    sg[5].setField(snack.Textbox(19, 1, TAG_MOUNT_POINT), \
++                        0, 0, (-12, 0, 0, 0))
++    txt_mountpt = snack.Entry(15, szMountpt, scroll = 0)
++    sg[5].setField(txt_mountpt, 1, 0, (0, 0, 0, 0))
++    sg[5].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    for i in range(0, 6):
++        g.add(sg[i], 0, i, (0, 0, 0, 0))
++
++    #Add buttons
++    g.add(bb, 0, 6, (0, 1, 0, -1))
++
++    # Display window
++    while True:
++        result = bb.buttonPressed(g.run())
++
++        if result == "ok":
++            rcode = "n"
++            break
++        elif result == "back":
++            rcode = "b"
++            break
++
++    # set From Directory
++    fromdir = txt_fromdir.value()
++    fromdir = fromdir.strip()
++
++    # set To Directory
++    todir = txt_todir.value()
++    todir = todir.strip()
++
++    # set Filesystem
++    filesystem = txt_filesystem.value()
++    filesystem = filesystem.strip()
++
++    # set Image size
++    imgsize = txt_imgsize.value()
++    imgsize = imgsize.strip()
++
++    # set Loop device
++    loopdev = txt_loopdev.value()
++    loopdev = loopdev.strip()
++
++    # set Mount point
++    mountpt = txt_mountpt.value()
++    mountpt = mountpt.strip()
++    insScreen.popWindow()
++    return (rcode, fromdir, todir, imgsize, loopdev, mountpt, filesystem)
++
++
++#------------------------------------------------------------
++# def MKIMGRAWWindowCtrl()
++#
++#   WindowCtrl for making RAW image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGRAWWindowCtrl(insScreen, insMKIMGInfo):
++
++    ERR_ITEM_IMAGE_SIZE  = "Image size"
++    ERR_ITEM_LOOP_DEVICE = "Use loop device"
++    ERR_ITEM_MOUNT_POINT = "Use mount point"
++
++    while True:
++        # Get the default value for RAW
++        (szimgsize, limgsize, szloopdev, szmountpt, ifilesystem) = \
++                insMKIMGInfo.get_raw_param()
++
++        szFromdir = insMKIMGInfo.get_from_dir_path()
++        szTodir = insMKIMGInfo.get_to_dir_path()
++
++        # Completion the Todir if image_file_name exists
++        if insMKIMGInfo.get_image_file_name():
++           szTodir = szTodir + "/" + insMKIMGInfo.get_image_file_name()
++
++        (rcode, szFromdir, szTodir, szimgsize, szloopdev, szmountpt, ifilesystem) =\
++            MKIMGSetupRAWWindow(insScreen, szFromdir, szTodir, szimgsize,\
++                                   szloopdev, szmountpt, ifilesystem)
++
++        # Change relative path to absolute path
++        szFromdir = os.path.abspath(szFromdir);
++        szTodir = os.path.abspath(szTodir);
++
++        # Set values for insMKIMGInfo
++        insMKIMGInfo.set_raw_param(szimgsize, szloopdev, szmountpt, ifilesystem)
++        insMKIMGInfo.set_from_dir_path(szFromdir)
++        insMKIMGInfo.set_to_dir_path(szTodir)
++
++        # Check input paras
++        if rcode == "n":
++            (err, err_str) = insMKIMGInfo.check_from_dir_path()
++            if err != 0:
++                item = err_str
++                ButtonErrorWindow(insScreen, item)
++                continue
++
++            err = insMKIMGInfo.check_raw_param()
++            if err != 0:
++                item = ""
++                if err == MKIMG_LABEL_IMG_SIZE:
++                    item = ERR_ITEM_IMAGE_SIZE
++                elif err == MKIMG_LABEL_LOOP_DEV:
++                    item = ERR_ITEM_LOOP_DEVICE
++                elif err == MKIMG_LABEL_MOUNT_PT:
++                    item = ERR_ITEM_MOUNT_POINT
++                ButtonErrorWindow(insScreen, item)
++                continue
++
++            else:
++                # transfer string to long int
++                insMKIMGInfo.set_raw_long_param()
++                break;
++
++        if rcode == "b":
++            # back
++            return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmRAWWindow()
++#
++#   Display Confirm Window before making image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szFromdir    : Path of From-directory
++#    szTodir      : Path of To-directory
++#    szImgfile    : Name of img file
++#    lImgsize     : Image size (long)
++#    szLoopdev    : Path of Loop device (default:/dev/loop0)
++#    szMountpt    : Path of Mount point (default:/mnt)
++#    iFilesystem  : Filesystem (the same as host)
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#------------------------------------------------------------
++def MKIMGConfirmRAWWindow(insScreen, szFromdir, szTodir, szImgfile, \
++                          lImgsize, szLoopdev, szMountpt, iFilesystem):
++
++    TAG_FROM_DIR    = "From directory:"
++    TAG_TO_DIR      = "To directory:"
++    TAG_IMG_TYP     = "Image type      : "
++    TAG_IMG_FILE    = "Image file name : "
++    TAG_IMG_SIZE    = "Image size      : "
++    TAG_FILESYSTEM  = "Filesystem type : "
++    TAG_LOOP_DEVICE = "Use loop device : "
++    TAG_MOUNT_POINT = "Use mount point : "
++    TAG_INDENT_SPACE= "  "
++
++    # Create Main Text
++    (main_width, main_height) = GetButtonMainSize(insScreen)
++
++    wrapper = textwrap.TextWrapper(width = main_width - 2)
++
++    wrapper.initial_indent    = "  "
++    wrapper.subsequent_indent = "  "
++
++    lst_text = []
++
++    lst_text.append("Are you sure to start making filesystem image ?\n\n")
++
++    lst_text.append(TAG_FROM_DIR + "\n")
++    lst_text.append(wrapper.fill(szFromdir) + "\n\n")
++
++    lst_text.append(TAG_TO_DIR + "\n")
++    lst_text.append(wrapper.fill(szTodir) + "\n\n")
++
++    lst_text.append(TAG_IMG_TYP + "RAW\n")
++
++    wrapper.initial_indent    = TAG_IMG_FILE
++    wrapper.subsequent_indent = TAG_INDENT_SPACE
++    lst_text.append(wrapper.fill(szImgfile) + "\n")
++
++    imgsize  = "%d" % lImgsize
++    lst_text.append(TAG_IMG_SIZE   + imgsize + " bytes\n")
++    lst_text.append(TAG_FILESYSTEM + iFilesystem + "\n")
++    lst_text.append(TAG_LOOP_DEVICE + szLoopdev + "\n")
++    lst_text.append(TAG_MOUNT_POINT + szMountpt + "\n")
++
++    # List To Text
++    main_text = "".join(lst_text)
++    del lst_text
++
++    # Create Button list
++    buttons = ["OK", "Back", "Exit"]
++
++    rcode = ButtonInfoWindow(insScreen, "Ready ?", main_text, \
++                              main_width, main_height, buttons)
++
++    return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmRAWWindowCtrl()
++#
++#   Confirm for making RAW image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGConfirmRAWWindowCtrl(insScreen, insMKIMGInfo):
++    # Get Parameters
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgfile = insMKIMGInfo.get_image_file_name()
++
++    (szimgsize, limgsize, szloopdev, szmountpt, ifilesystem) = \
++                               insMKIMGInfo.get_raw_param()
++
++    szloopdev = os.path.abspath(szloopdev)
++    szmountpt = os.path.abspath(szmountpt)
++
++    while True:
++        rcode = MKIMGConfirmRAWWindow(insScreen, fromdir, todir, imgfile,\
++                                         limgsize, szloopdev, szmountpt, ifilesystem)
++
++        if rcode == "e":
++            # exit
++            insScreen.popHelpLine()
++            insScreen.popWindow()
++            exit_hkey = HotkeyExitWindow(insScreen)
++            if exit_hkey == "y":
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++                    sys.exit(0)
++
++        elif rcode == "o":
++            logfile = imgfile + ".log"
++            try:
++                fdLog = OpenLogFile(logfile)
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++
++                MKIMGCreateRAW(insMKIMGInfo, fdLog)
++                sys.exit(0)
++
++            finally:
++                # Log File Close
++                fdLog.close()
++                sys.exit(0)
++
++        else:
++            # back
++            return rcode
++
++#-----------------------------------------------------------
++# def MKIMGCreateRAW()
++#
++#   Create RAW image.
++#
++# Input:
++#    insMKIMGInfo : instance of class MKIMGInfo
++#    fdLog        : file descriptor of Log file
++# Output:
++#    bool         : success=True, fail=False
++#-----------------------------------------------------------
++def MKIMGCreateRAW(insMKIMGInfo, fdLog):
++
++    MSG_START        = "Making the RAW image start."
++    MSG_END_SUCCESS  = "\nMaking the RAW image succeeded."
++    MSG_END_FAILED   = "\nMaking the RAW image failed."
++    MSG_FINISH       = "RootFS Image Maker finish."
++    ERR_MSG_CREATE_SIZE = "WARNING: The image file size is larger than the specified size !!"
++
++    print(MSG_START)
++    fdLog.write(MSG_START + "\n")
++
++    rcode = True
++
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgname = insMKIMGInfo.get_image_file_name()
++    imgpath = todir + "/" + imgname
++
++    (szimgsize, limgsize, szloop, szmountpt, filesystem) = insMKIMGInfo.get_raw_param()
++
++    szloop    = os.path.abspath(szloop)
++    szmountpt = os.path.abspath(szmountpt)
++
++    # utils for mkfs command
++    mkfscmd = "mkfs.%s" % filesystem
++
++    # calculate count
++    count = int(limgsize/MKIMG_BLOCK_SIZE)
++
++    # Init all cmd steps
++    cmd_steps = { 0: "dd if=/dev/zero of=\'%s\' bs=%s count=%s" %(imgpath, MKIMG_BLOCK_SIZE, count), \
++                  1: "/sbin/losetup \'%s\' \'%s\'" %(szloop, imgpath), \
++                  2: "/sbin/%s \'%s\'" %(mkfscmd, szloop),
++                  3: "mount -t %s \'%s\' \'%s\'" %(filesystem, szloop, szmountpt), \
++                  4: "cd \'%s\'; find . -print | cpio -p \'%s\'" %(fromdir, szmountpt), \
++                  5: "umount \'%s\'" %szmountpt, \
++                  6: "/sbin/losetup -d \'%s\'" %szloop \
++                   }
++
++    # Execute Commands
++    step = 0
++    while step < 7:
++        cmd = cmd_steps[step]
++        if ExecAndOutLog(cmd, fdLog) != 0:
++            rcode = False
++            if step == 2 or step == 3:
++                step = 6
++                continue
++            if step == 4 or step == 5:
++                step = step + 1
++                continue
++            else:
++                break
++
++        step = step + 1
++
++    if rcode == True:
++        os.chmod(imgpath, 0o644)
++        print(MSG_END_SUCCESS)
++        fdLog.write(MSG_END_SUCCESS + "\n")
++    else:
++        print(MSG_END_FAILED)
++        fdLog.write(MSG_END_FAILED + "\n")
++
++    print(MSG_FINISH)
++    fdLog.write(MSG_FINISH + "\n")
++
++    if rcode == True:
++        rcode = 0
++    else:
++        rcode = -1
++
++    return rcode
+diff --git a/dnf-plugins/mkimg/MKIMGSquashFSWindow.py b/dnf-plugins/mkimg/MKIMGSquashFSWindow.py
+new file mode 100755
+index 0000000..b38aef0
+--- /dev/null
++++ b/dnf-plugins/mkimg/MKIMGSquashFSWindow.py
+@@ -0,0 +1,332 @@
++#
++# Copyright (C) Fujitsu Limited 2018 All rights reserved
++#
++
++import os
++from ..window import *
++from .ExecAndOutLog import *
++from .OpenLogFile import *
++from .ButtonErrorWindow import *
++from .MKIMGInfo import *
++
++#------------------------------------------------------------
++# def MKIMGSetupSquashFSWindow()
++#
++#   Display SquashFS Setup Window.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szFromdir    : Path of From-directory
++#    szTodir      : Path of To-directory
++#    szBlksize    : Block size (string)
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#    str : fromdir
++#    str : todir
++#    str : Block size
++#------------------------------------------------------------
++def MKIMGSetupSquashFSWindow(insScreen, szFromdir=".rootfs-x86", szTodir="rootfs.SquashFS.bin", \
++                        szBlksize="4096"):
++    TAG_SRC_DIR     = "From directory  : "
++    TAG_TARGET_DIR  = "To directory    : "
++    TAG_BLOCK_SIZE  = "Block size"
++
++    # Create Button instance
++    buttons = (("OK", "ok"), ("Back", "back"))
++    bb = snack.ButtonBar(insScreen, buttons)
++
++    # Create Grid instance
++    g = snack.GridForm(insScreen, "SquashFS Parameter", 1, 7)
++
++    #init snack.Grid object dict
++    sg = {}
++    for i in range(0, 3):
++        sg[i] = snack.Grid(3, 1)
++
++    # source directory
++    sg[0].setField(snack.Textbox(19, 1, TAG_SRC_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_fromdir = snack.Entry(29, szFromdir, scroll = 1)
++    sg[0].setField(txt_fromdir, 1, 0, (0, 0, 0, 0))
++    sg[0].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # target directory
++    sg[1].setField(snack.Textbox(19, 1, TAG_TARGET_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_todir = snack.Entry(29, szTodir, scroll = 1)
++    sg[1].setField(txt_todir, 1, 0, (0, 0, 0, 0))
++    sg[1].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # Block size
++    sg[2].setField(snack.Textbox(19, 1, TAG_BLOCK_SIZE), \
++                        0, 0, (-12, 0, 0, 0))
++    txt_blksize = snack.Entry(15, szBlksize, scroll = 0)
++    sg[2].setField(txt_blksize, 1, 0, (0, 0, 0, 0))
++    sg[2].setField(snack.Textbox(5, 1, "bytes"), 2, 0, (0, 0, 0, 0))
++
++    for i in range(0, 3):
++        g.add(sg[i], 0, i, (0, 0, 0, 0))
++
++    #Add buttons
++    g.add(bb, 0, 6, (0, 1, 0, -1))
++
++    # Display window
++    while True:
++        result = bb.buttonPressed(g.run())
++
++        if result == "ok":
++            rcode = "n"
++            break
++        elif result == "back":
++            rcode = "b"
++            break
++
++    # set From Directory
++    fromdir = txt_fromdir.value()
++    fromdir = fromdir.strip()
++
++    # set To Directory
++    todir = txt_todir.value()
++    todir = todir.strip()
++
++    # set Block size
++    blksize = txt_blksize.value()
++    blksize = blksize.strip()
++
++    insScreen.popWindow()
++    return (rcode, fromdir, todir, blksize)
++
++
++#------------------------------------------------------------
++# def MKIMGSquashFSWindowCtrl()
++#
++#   WindowCtrl for making SquashFS image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGSquashFSWindowCtrl(insScreen, insMKIMGInfo):
++
++    ERR_ITEM_BLOCK_SIZE  = "Block size"
++
++    while True:
++        # Get the default value for SquashFS
++        (szimgsize, limgsize) = insMKIMGInfo.get_squashfs_param()
++
++        szFromdir = insMKIMGInfo.get_from_dir_path()
++        szTodir = insMKIMGInfo.get_to_dir_path()
++
++        # Completion the Todir if image_file_name exists
++        if insMKIMGInfo.get_image_file_name():
++           szTodir = szTodir + "/" + insMKIMGInfo.get_image_file_name()
++
++        (rcode, szFromdir, szTodir, szimgsize) = \
++            MKIMGSetupSquashFSWindow(insScreen, szFromdir, szTodir, szimgsize)
++
++        #Change relative path to absolute path
++        szFromdir = os.path.abspath(szFromdir);
++        szTodir = os.path.abspath(szTodir);
++
++        insMKIMGInfo.set_squashfs_param(szimgsize)
++        insMKIMGInfo.set_from_dir_path(szFromdir)
++        insMKIMGInfo.set_to_dir_path(szTodir)
++
++        # Check input params
++        if rcode == "n":
++            (err, err_str) = insMKIMGInfo.check_from_dir_path()
++            if err != 0:
++                item = err_str
++                ButtonErrorWindow(insScreen, item)
++                continue
++
++            err = insMKIMGInfo.check_squashfs_param()
++            if err != 0:
++                item = ""
++                if err == MKIMG_LABEL_BLK_SIZE:
++                    item = ERR_ITEM_BLOCK_SIZE
++
++                ButtonErrorWindow(insScreen, item)
++                continue
++
++            else:
++                # transfer string to long int
++                insMKIMGInfo.set_squashfs_long_param()
++                break;
++
++        if rcode == "b":
++            # back
++            return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmSquashFSWindow()
++#
++#   Display Confirm Window before making image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szFromdir    : Path of From-directory
++#    szTodir      : Path of To-directory
++#    szImgfile    : Name of Imgfile
++#    lblksize     : Block size(long)
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#------------------------------------------------------------
++def MKIMGConfirmSquashFSWindow(insScreen, szFromdir, szTodir, szImgfile, lblksize):
++
++    TAG_FROM_DIR    = "From directory:"
++    TAG_TO_DIR      = "To directory:"
++    TAG_IMG_TYP     = "Image type      : "
++    TAG_IMG_FILE    = "Image file name : "
++    TAG_BLK_SIZE    = "block size      : "
++    TAG_INDENT_SPACE= "                  "
++
++
++    # Create Main Text
++    (main_width, main_height) = GetButtonMainSize(insScreen)
++
++    wrapper = textwrap.TextWrapper(width = main_width - 2)
++
++    wrapper.initial_indent    = "  "
++    wrapper.subsequent_indent = "  "
++
++    lst_text = []
++
++    lst_text.append("Are you sure to start making filesystem image ?\n\n")
++
++    lst_text.append(TAG_FROM_DIR + "\n")
++    lst_text.append(wrapper.fill(szFromdir) + "\n\n")
++
++    lst_text.append(TAG_TO_DIR + "\n")
++    lst_text.append(wrapper.fill(szTodir) + "\n\n")
++
++    lst_text.append(TAG_IMG_TYP + "SquashFS\n")
++
++    wrapper.initial_indent    = TAG_IMG_FILE
++    wrapper.subsequent_indent = TAG_INDENT_SPACE
++    lst_text.append(wrapper.fill(szImgfile) + "\n")
++
++    blksize  = "%d" % lblksize
++    lst_text.append(TAG_BLK_SIZE   + blksize + " bytes\n")
++
++    # List To Text
++    main_text = "".join(lst_text)
++    del lst_text
++
++    # Create Button list
++    buttons = ["OK", "Back", "Exit"]
++
++    rcode = ButtonInfoWindow(insScreen, "Ready ?", main_text, \
++                              main_width, main_height, buttons)
++
++    return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmSquashFSWindowCtrl()
++#
++#   Confirm for making SquashFS image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGConfirmSquashFSWindowCtrl(insScreen, insMKIMGInfo):
++    # Get Parameters
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgfile = insMKIMGInfo.get_image_file_name()
++
++    (szblksize, lblksize) = insMKIMGInfo.get_squashfs_param()
++
++    while True:
++        rcode = MKIMGConfirmSquashFSWindow(insScreen, fromdir, todir, imgfile, lblksize)
++
++        if rcode == "e":
++            # exit
++            insScreen.popHelpLine()
++            insScreen.popWindow()
++            exit_hkey = HotkeyExitWindow(insScreen)
++            if exit_hkey == "y":
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++                    sys.exit(0)
++
++        elif rcode == "o":
++            logfile = imgfile + ".log"
++            try:
++                fdLog = OpenLogFile(logfile)
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++
++                MKIMGCreateSquashFS(insMKIMGInfo, fdLog)
++                sys.exit(0)
++
++            finally:
++                # Log File Close
++                fdLog.close()
++                sys.exit(0)
++
++        else:
++            # back
++            return rcode
++
++#-----------------------------------------------------------
++# def MKIMGCreateSquashFS()
++#
++#   Create SquashFS image.
++#
++# Input:
++#    insMKIMGInfo : instance of class MKIMGInfo
++#    fdLog        : file descriptor of Log file
++# Output:
++#    bool         : success=True, fail=False
++#-----------------------------------------------------------
++def MKIMGCreateSquashFS(insMKIMGInfo, fdLog):
++
++    MSG_START        = "Making the SquashFS image start."
++    MSG_END_SUCCESS  = "\nMaking the SquashFS image succeeded."
++    MSG_END_FAILED   = "\nMaking the SquashFS image failed."
++    MSG_FINISH       = "RootFS Image Maker finish."
++
++    print(MSG_START)
++    fdLog.write(MSG_START + "\n")
++
++    rcode = True
++
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgname = insMKIMGInfo.get_image_file_name()
++    imgpath = todir + "/" + imgname
++
++    (szblksize, lblksize) = insMKIMGInfo.get_squashfs_param()
++
++    # Execute Commands
++    cmd = "mksquashfs %s %s -noappend -b %s " % \
++             (fromdir, imgpath, lblksize)
++
++    if ExecAndOutLog(cmd, fdLog) != 0:
++        rcode = False
++
++    if rcode == True:
++        os.chmod(imgpath, 0o644)
++        print(MSG_END_SUCCESS)
++        fdLog.write(MSG_END_SUCCESS + "\n")
++    else:
++        print(MSG_END_FAILED)
++        fdLog.write(MSG_END_FAILED + "\n")
++
++    print(MSG_FINISH)
++    fdLog.write(MSG_FINISH + "\n")
++
++    if rcode == True:
++        rcode = 0
++    else:
++        rcode = -1
++
++    return rcode
+diff --git a/dnf-plugins/mkimg/MKIMGUBIFSWindow.py b/dnf-plugins/mkimg/MKIMGUBIFSWindow.py
+new file mode 100755
+index 0000000..63772f8
+--- /dev/null
++++ b/dnf-plugins/mkimg/MKIMGUBIFSWindow.py
+@@ -0,0 +1,379 @@
++#
++# Copyright (C) Fujitsu Limited 2018 All rights reserved
++#
++
++import os
++from ..window import *
++from .ExecAndOutLog import *
++from .OpenLogFile import *
++from .ButtonErrorWindow import *
++from .MKIMGInfo import *
++
++#------------------------------------------------------------
++# def MKIMGSetupUBIFSWindow()
++#
++#   Display UBIFS Setup Window.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szFromdir    : Path of From-directory
++#    szTodir      : Path of To-directory
++#    szMinSize    : Minimum I/O unit size
++#    szLeb        : Logical erase block size
++#    szMeb        : Maximum logical erase block count
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#    str : fromdir
++#    str : todir
++#    str : blksize
++#    str : leb
++#    str : meb
++#------------------------------------------------------------
++def MKIMGSetupUBIFSWindow(insScreen, szFromdir=".rootfs-x86", szTodir="rootfs.ubifs.bin", \
++                        szMinSize='512', szLeb='131072', szMeb='3000'):
++
++    TAG_SRC_DIR     = "From directory  : "
++    TAG_TARGET_DIR  = "To directory    : "
++    TAG_MINSIZE     = "Minimum I/O unit size             : "
++    TAG_LEB         = "Logical erase block size( > 15360): "
++    TAG_MEB         = "Maximum logical erase block count : "
++
++    # Create Button instance
++    buttons = (("OK", "ok"), ("Back", "back"))
++    bb = snack.ButtonBar(insScreen, buttons)
++
++    # Create Grid instance
++    g = snack.GridForm(insScreen, "UBIFS Parameter", 1, 7)
++
++    #init snack.Grid object dict
++    sg = {}
++    for i in range(0, 5):
++        sg[i] = snack.Grid(3, 1)
++
++    # source directory
++    sg[0].setField(snack.Textbox(19, 1, TAG_SRC_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_fromdir = snack.Entry(32, szFromdir, scroll = 1)
++    sg[0].setField(txt_fromdir, 1, 0, (0, 0, 0, 0))
++    sg[0].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    # target directory
++    sg[1].setField(snack.Textbox(19, 1, TAG_TARGET_DIR), \
++                        0, 0, (2, 0, 0, 0))
++    txt_todir = snack.Entry(32, szTodir, scroll = 1)
++    sg[1].setField(txt_todir, 1, 0, (0, 0, 0, 0))
++    sg[1].setField(snack.Textbox(5, 1, ""), 2, 0, (0, 0, 0, 0))
++
++    #  Minimam Block Size
++    sg[2].setField(snack.Textbox(36, 1, TAG_MINSIZE), \
++                        0, 0, (2, 0, 0, 0))
++    txt_blksize = snack.Entry(15, szMinSize, scroll = 0)
++    sg[2].setField(txt_blksize, 1, 0, (0, 0, 0, 0))
++    sg[2].setField(snack.Textbox(5, 1, "bytes"), 2, 0, (0, 0, 0, 0))
++
++    # Logical Erase Block
++    sg[3].setField(snack.Textbox(36, 1, TAG_LEB), \
++                        0, 0, (2, 0, 0, 0))
++    txt_leb = snack.Entry(15, szLeb, scroll = 0)
++    sg[3].setField(txt_leb, 1, 0, (0, 0, 0, 0))
++    sg[3].setField(snack.Textbox(5, 1, "bytes"), 2, 0, (0, 0, 0, 0))
++
++    # Maximam Erase Block
++    sg[4].setField(snack.Textbox(36, 1, TAG_MEB), \
++                        0, 0, (2, 0, 0, 0))
++    txt_meb = snack.Entry(15, szMeb, scroll = 0)
++    sg[4].setField(txt_meb, 1, 0, (0, 0, 0, 0))
++    sg[4].setField(snack.Textbox(5, 1, "count"), 2, 0, (0, 0, 0, 0))
++
++    for i in range(0, 5):
++        g.add(sg[i], 0, i, (0, 0, 0, 0))
++
++    #Add buttons
++    g.add(bb, 0, 6, (0, 1, 0, -1))
++
++    # Display window
++    while True:
++        result = bb.buttonPressed(g.run())
++
++        if result == "ok":
++            rcode = "n"
++            break
++        elif result == "back":
++            rcode = "b"
++            break
++
++    # set From Directory
++    fromdir = txt_fromdir.value()
++    fromdir = fromdir.strip()
++
++    # set To Directory
++    todir = txt_todir.value()
++    todir = todir.strip()
++
++    # set block size
++    blksize = txt_blksize.value()
++    blksize = blksize.strip()
++
++    # set logical block size
++    leb = txt_leb.value()
++    leb = leb.strip()
++
++    # set maximam block size
++    meb = txt_meb.value()
++    meb = meb.strip()
++
++    insScreen.popWindow()
++    return (rcode, fromdir, todir, blksize, leb, meb)
++
++#------------------------------------------------------------
++# def MKIMGUBIFSWindowCtrl()
++#
++#   WindowCtrl for making UBIFS image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGUBIFSWindowCtrl(insScreen, insMKIMGInfo):
++
++    ERR_ITEM_MIN  = "minimum I/O unit size"
++    ERR_ITEM_LEB = "Logical Erase Block"
++    ERR_ITEM_MEB = "Maximam Erase Block"
++
++    while True:
++        # Get the default value for UBIFS
++        (szblksize, lblksize, szleb, lleb, szmeb, lmeb) = \
++                insMKIMGInfo.get_ubifs_param()
++
++        szFromdir = insMKIMGInfo.get_from_dir_path()
++        szTodir = insMKIMGInfo.get_to_dir_path()
++
++        # Completion the Todir if image_file_name exists
++        if insMKIMGInfo.get_image_file_name():
++           szTodir = szTodir + "/" + insMKIMGInfo.get_image_file_name()
++
++        (rcode, szFromdir, szTodir, szblksize, szleb, szmeb) = \
++            MKIMGSetupUBIFSWindow(insScreen, szFromdir, szTodir, szblksize, szleb, szmeb)
++
++        #Change relative path to absolute path
++        szFromdir = os.path.abspath(szFromdir);
++        szTodir = os.path.abspath(szTodir);
++
++        insMKIMGInfo.set_ubifs_param(szblksize, szleb, szmeb)
++        insMKIMGInfo.set_from_dir_path(szFromdir)
++        insMKIMGInfo.set_to_dir_path(szTodir)
++
++        # Check input params
++        if rcode == "n":
++            (err, err_str) = insMKIMGInfo.check_from_dir_path()
++            if err != 0:
++                item = err_str
++                ButtonErrorWindow(insScreen, item)
++                continue
++
++            err = insMKIMGInfo.check_ubifs_param()
++            if err != 0:
++                item = ""
++                if err == MKIMG_LABEL_BLK_SIZE:
++                    item = ERR_ITEM_MIN
++                elif err == MKIMG_LABEL_LEB_SIZE:
++                    item = ERR_ITEM_LEB
++                elif err == MKIMG_LABEL_MEB_SIZE:
++                    item = ERR_ITEM_MEB
++
++                ButtonErrorWindow(insScreen, item)
++                continue
++
++            else:
++                # transfer string to long int
++                insMKIMGInfo.set_ubifs_long_param()
++                break;
++
++        if rcode == "b":
++            # back
++            return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmUBIFSWindow()
++#
++#   Display Confirm Window before making image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    szFromdir    : Path of From-directory
++#    szImgfile    : Name of Imgfile
++#    szTodir      : Path of To-directory
++#    lblksize     : Minimum I/O unit size (long)
++#    lleb         : Logical erase block size(long)
++#    lmeb         : Maximum logical erase block count(long)
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back, "e" : Exit)
++#------------------------------------------------------------
++def MKIMGConfirmUBIFSWindow(insScreen, szFromdir, szTodir, szImgfile, \
++                          lblksize, lleb, lmeb):
++
++    TAG_FROM_DIR    = "From directory:"
++    TAG_TO_DIR      = "To directory:"
++    TAG_IMG_TYP     = "Image type      : "
++    TAG_IMG_FILE    = "Image file name                   : "
++    TAG_BLK_SIZE    = "Minimum I/O unit size             : "
++    TAG_LEB         = "Logical erase block size          : "
++    TAG_MEB         = "Maximum logical erase block count : "
++    TAG_INDENT_SPACE= "                                    "
++
++    # Create Main Text
++    (main_width, main_height) = GetButtonMainSize(insScreen)
++
++    wrapper = textwrap.TextWrapper(width = main_width - 2)
++
++    wrapper.initial_indent    = "  "
++    wrapper.subsequent_indent = "  "
++
++    lst_text = []
++
++    lst_text.append("Are you sure to start making filesystem image ?\n\n")
++
++    lst_text.append(TAG_FROM_DIR + "\n")
++    lst_text.append(wrapper.fill(szFromdir) + "\n\n")
++
++    lst_text.append(TAG_TO_DIR + "\n")
++    lst_text.append(wrapper.fill(szTodir) + "\n\n")
++
++    lst_text.append(TAG_IMG_TYP + "UBIFS\n")
++
++    wrapper.initial_indent    = TAG_IMG_FILE
++    wrapper.subsequent_indent = TAG_INDENT_SPACE
++    lst_text.append(wrapper.fill(szImgfile) + "\n")
++
++    blksize  = "%d" % lblksize
++    lst_text.append(TAG_BLK_SIZE + blksize + " bytes\n")
++
++    leb  = "%d" % lleb
++    lst_text.append(TAG_LEB + leb + " bytes\n")
++
++    meb = "%d" % lmeb
++    lst_text.append(TAG_MEB + meb + " count\n")
++
++    # List To Text
++    main_text = "".join(lst_text)
++    del lst_text
++
++    # Create Button list
++    buttons = ["OK", "Back", "Exit"]
++
++    rcode = ButtonInfoWindow(insScreen, "Ready ?", main_text, \
++                              main_width, main_height, buttons)
++
++    return rcode
++
++#------------------------------------------------------------
++# def MKIMGConfirmUBIFSWindowCtrl()
++#
++#   Confirm for making UBIFSFS image.
++#
++# Input:
++#    insScreen    : instance of snack screen
++#    insMKIMGInfo : instance of class MKIMGInfo
++# Output:
++#    str : pressed button ("n" : OK, "b" : Back)
++#------------------------------------------------------------
++def MKIMGConfirmUBIFSWindowCtrl(insScreen, insMKIMGInfo):
++    # Get Parameters
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgfile = insMKIMGInfo.get_image_file_name()
++
++    (szblksize, lblksize, szleb, lleb, szmeb, lmeb) = \
++                               insMKIMGInfo.get_ubifs_param()
++
++    while True:
++        rcode = MKIMGConfirmUBIFSWindow(insScreen, fromdir, todir, imgfile,\
++                                      lblksize, lleb, lmeb)
++
++        if rcode == "e":
++            # exit
++            insScreen.popHelpLine()
++            insScreen.popWindow()
++            exit_hkey = HotkeyExitWindow(insScreen)
++            if exit_hkey == "y":
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++                    sys.exit(0)
++
++        elif rcode == "o":
++            logfile = imgfile + ".log"
++            try:
++                fdLog = OpenLogFile(logfile)
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++
++                MKIMGCreateUBIFS(insMKIMGInfo, fdLog)
++                sys.exit(0)
++
++            finally:
++                # Log File Close
++                fdLog.close()
++                sys.exit(0)
++
++        else:
++            # back
++            return rcode
++
++#-----------------------------------------------------------
++# def MKIMGCreateUBIFS()
++#
++#   Create UBIFS image.
++#
++# Input:
++#    insMKIMGInfo : instance of class MKIMGInfo
++#    fdLog        : file descriptor of Log file
++# Output:
++#    bool         : success=True, fail=False
++#-----------------------------------------------------------
++def MKIMGCreateUBIFS(insMKIMGInfo, fdLog):
++
++    MSG_START        = "Making the UBIFS image start."
++    MSG_END_SUCCESS  = "\nMaking the UBIFS image succeeded."
++    MSG_END_FAILED   = "\nMaking the UBIFS image failed."
++    MSG_FINISH       = "RootFS Image Maker finish."
++    ERR_MSG_CREATE_SIZE = "WARNING: The image file size is larger than the specified size !!"
++
++    print(MSG_START)
++    fdLog.write(MSG_START + "\n")
++
++    rcode = True
++
++    fromdir = insMKIMGInfo.get_from_dir_path()
++    todir   = insMKIMGInfo.get_to_dir_path()
++    imgname = insMKIMGInfo.get_image_file_name()
++    imgpath = todir + "/" + imgname
++
++    (szblksize, lblksize, szleb, lleb, szmeb, lmeb) = insMKIMGInfo.get_ubifs_param()
++
++    # Execute Commands
++    cmd = "mkfs.ubifs -m %s -e %s -c %s -r %s %s " % \
++             (lblksize, lleb, lmeb, fromdir, imgpath)
++    if ExecAndOutLog(cmd, fdLog) != 0:
++        rcode = False
++
++    if rcode == True:
++        os.chmod(imgpath, 0o644)
++        print(MSG_END_SUCCESS)
++        fdLog.write(MSG_END_SUCCESS + "\n")
++    else:
++        print(MSG_END_FAILED)
++        fdLog.write(MSG_END_FAILED + "\n")
++
++    print(MSG_FINISH)
++    fdLog.write(MSG_FINISH + "\n")
++
++    if rcode == True:
++        rcode = 0
++    else:
++        rcode = -1
++
++    return rcode
+diff --git a/dnf-plugins/mkimg/OpenLogFile.py b/dnf-plugins/mkimg/OpenLogFile.py
+new file mode 100644
+index 0000000..b3b8327
+--- /dev/null
++++ b/dnf-plugins/mkimg/OpenLogFile.py
+@@ -0,0 +1,27 @@
++#
++# Copyright (C) Fujitsu Limited 2018  All rights reserved
++#
++
++import sys, os
++
++#-----------------------------------------------------------
++# def OpenLogFile()
++#
++#   Open Log file and return file descriptor
++#
++# Input:
++#   sLogpath : path of Log file
++# Output:
++#   fd       : file descriptor of Log file
++#-----------------------------------------------------------
++def OpenLogFile(sLogpath):
++
++    # Log file open
++    try:
++        fd = open(sLogpath, "w")
++    except Exception as e:
++        print("%s: Can not open log file: %s",sys.stderr %(sys.argv[0], sLogpath, e))
++        fd = open("/dev/null", "w")
++
++    return fd
++
+diff --git a/dnf-plugins/tui.py b/dnf-plugins/tui.py
+new file mode 100755
+index 0000000..ff8c3bc
+--- /dev/null
++++ b/dnf-plugins/tui.py
+@@ -0,0 +1,1001 @@
++# tui.py
++# Tgui CLI command.
++#
++# Copyright (C) 2018 FUJITSU LIMITED
++#
++from __future__ import absolute_import
++from __future__ import unicode_literals
++from dnf.cli import commands
++from dnf.cli.option_parser import OptionParser
++from dnf.i18n import _
++from itertools import chain
++import dnf.subject
++
++import dnf.exceptions
++import hawkey
++import logging
++
++from .window import *
++from .utils import fetchSPDXorSRPM, read_environ
++import sys, os, copy, textwrap, snack, string, time, re, shutil, hashlib
++from snack import *
++
++from .Define import _TXT_ROOT_TITLE, Install_actions, Custom_actions, Image_types
++from .mkimg.MKIMGJFFS2Window import *
++from .mkimg.MKIMGINITRAMFSWindow import *
++from .mkimg.MKIMGINITRDWindow import *
++from .mkimg.MKIMGRAWWindow import *
++from .mkimg.MKIMGSquashFSWindow import *
++from .mkimg.MKIMGUBIFSWindow import *
++from .mkimg.MKIMGInfo import *
++
++import dnf
++import dnf.cli.demand
++import dnf.cli.option_parser
++import dnf.cli.commands.shell
++import dnf.conf
++from dnf.cli.option_parser import OptionParser
++import dnf.conf.substitutions
++import dnf.const
++import dnf.exceptions
++import dnf.cli.format
++import dnf.logging
++import dnf.plugin
++import dnf.persistor
++import dnf.rpm
++import dnf.cli.utils
++import dnf.yum.misc
++from subprocess import call
++
++#Make image function entrance
++Image_type_functions = { 0: [MKIMGJFFS2WindowCtrl, MKIMGConfirmJFFS2WindowCtrl],
++                         1: [MKIMGINITRAMFSWindowCtrl, MKIMGConfirmINITRAMFSWindowCtrl],
++                         2: [MKIMGINITRDWindowCtrl, MKIMGConfirmINITRDWindowCtrl],
++                         3: [MKIMGRAWWindowCtrl, MKIMGConfirmRAWWindowCtrl],
++                         4: [MKIMGSquashFSWindowCtrl, MKIMGConfirmSquashFSWindowCtrl],
++                         5: [MKIMGUBIFSWindowCtrl, MKIMGConfirmUBIFSWindowCtrl]
++                       }
++
++Image_type_name      = { 0: "rootfs.jffs2.bin",
++                         1: "rootfs.initramfs.cpio",
++                         2: "rootfs.initrd.bin",
++                         3: "rootfs.raw.bin",
++                         4: "rootfs.SquashFS.bin",
++                         5: "rootfs.ubifs.bin"
++                       }
++
++ACTION_INSTALL     = 0
++ACTION_REMOVE      = 1
++ACTION_UPGRADE     = 2
++ACTION_GET_PKG     = 3
++ACTION_GET_SOURCE  = 4
++ACTION_GET_SPDX    = 5
++ACTION_GET_ALL     = 6
++ACTION_MAKE_IMG    = 7
++GROUP_INSTALL      = 8
++
++NEW_INSTALL        = 0
++RECORD_INSTALL     = 1
++SAMPLE_INSTALL     = 2
++
++CONFIRM_EXIT       = 0
++CONFIRM_INSTALL    = 1
++CONFIRM_LICENSE    = 2
++CONFIRM_REMOVE     = 3
++CONFIRM_UPGRADE    = 4
++CONFIRM_GET_PKG    = 5
++CONFIRM_GET_SOURCE = 6
++CONFIRM_GET_SPDX   = 7
++CONFIRM_GET_ALL    = 8
++
++ATTENTON_NONE           = 0
++ATTENTON_HAVE_UPGRADE   = 1
++ATTENTON_NONE_UPGRADE   = 2
++
++if "OECORE_NATIVE_SYSROOT" in os.environ:
++    NATIVE_SYSROOT = os.environ["OECORE_NATIVE_SYSROOT"]
++else:
++    NATIVE_SYSROOT = "/opt/poky/2.6/sysroots/x86_64-pokysdk-linux"
++SAMPLE = NATIVE_SYSROOT + "/usr/share/dnf"
++
++logger = logging.getLogger('dnf')
++
++@dnf.plugin.register_command
++class TuiCommand(commands.Command):
++    """A class containing methods needed by the cli to execute the
++    tui command.
++    """
++
++    aliases = ('tui',)
++    summary = _('Enter tui interface.')
++
++    def __init__(self, cli=None):
++        cli = cli or dnf.cli.Cli()
++        super(TuiCommand, self).__init__(cli=cli)
++        self.screen = None
++        self.no_gpl3 = False
++        self.install_type = ACTION_INSTALL
++        self.image_type = 0
++
++        self.pkgnarrow = 'all'
++        self.patterns = None
++        self.installed_available = False
++        self.reponame = None
++        self.CONFIG_FILE = ".config"
++        self.grps = []
++        self.group_flag = False #Show hotkey 'F6' or not
++        self.group_botton = False #Press hotkey 'F6' or not
++        self.SAVE = True
++
++    @staticmethod
++    def set_argparser(parser):
++        parser.add_argument("--init", dest="with_init",
++                          action="store_true", default=None,
++                          help=_("Init the dnf environment for toolchain"))
++        parser.add_argument("--call", dest="with_call",
++                          action="store_true", default=None,
++                          help=_(""))
++        parser.add_argument("--auto", action="store_true", dest="auto",
++                                 default=None, help=_("Automatically complete installation"))
++        parser.add_argument("-i", "--installlist", dest="install_list",
++                          help=_("Package list file for installation"))
++
++    def pre_configure(self):
++        if self.opts.with_init:
++            plugin_dir = os.path.split(__file__)[0] #the dir of dnf-host script
++            os.system("%s/dnf-host init" %plugin_dir)
++            sys.exit(0)
++        if self.opts.with_call:
++            return
++        else:
++            #Reload the conf and args
++            env_path = os.getcwd() + "/.env-dnf"
++            if os.path.exists(env_path):
++                read_environ(env_path)
++
++                install_root_from_env = os.environ['HIDDEN_ROOTFS']
++                self.opts.installroot = install_root_from_env
++                self.opts.config_file_path = install_root_from_env + "/etc/dnf/dnf-host.conf"
++                self.opts.logdir = os.path.dirname(install_root_from_env)
++
++                if self.opts.auto:
++                    plugin_dir = os.path.split(__file__)[0]
++                    os.environ["LD_PRELOAD"] = ''
++                    os.system("%s/dnf-host --rootfs-tar --fetch-all --install_list %s" %(plugin_dir, self.opts.install_list))
++                    sys.exit(0)
++
++                #call subprocess dnf
++                tar = False
++                old_md5 = None
++
++                rpm_dbfile = self.opts.installroot + "/var/lib/rpm/Packages"
++                if os.path.exists(rpm_dbfile):
++                    f1 = open(rpm_dbfile, 'rb')
++                    old_md5 = hashlib.md5(f1.read()).hexdigest()
++
++                exit_code = call(["dnf", "tui", "--call", "-c{}".format(
++                                  self.opts.config_file_path), "--installroot={}".format(
++                                  self.opts.installroot), "--setopt=logdir={}".format(
++                                  self.opts.logdir), "--releasever=None"])
++                if exit_code != 0:
++                    raise dnf.exceptions.Error(_("Failed to call dnf tui"))
++
++                #When you choose tui, the rootfs will be made only after pkg operation
++                if old_md5:
++                    f2 = open(rpm_dbfile, 'rb')
++                    new_md5 = hashlib.md5(f2.read()).hexdigest()
++                    if old_md5 != new_md5:
++                        tar = True
++                elif os.path.exists(rpm_dbfile):
++                    tar = True
++
++                if tar:
++                    plugin_dir = os.path.split(__file__)[0]
++                    os.environ["LD_PRELOAD"] = ''
++                    os.system("%s/dnf-host --rootfs-tar" %plugin_dir)
++                sys.exit(0)
++
++            else:
++                logger.warning("Please Init the environment first!\nUsage: dnf tui --init")
++                sys.exit(0)
++
++    def configure(self):
++        self.cli.demands = dnf.cli.commands.shell.ShellDemandSheet()
++        demands = self.cli.demands
++        demands.root_user = False
++
++    def run(self, command=None, argv=None):
++        if self.opts.installroot:  #if used in toolchain
++            if self.opts.with_call:
++                logger.debug("Enter tui interface.")
++                self.PKGINSTDispMain()
++            else:
++                pass
++        else:
++            logger.debug("Enter tui interface.")
++            self.PKGINSTDispMain()
++
++    def run_dnf_command(self, s_line):
++        """Execute the subcommand you put in.
++        """
++        opts = self.cli.optparser.parse_main_args(s_line)
++        cmd_cls = self.cli.cli_commands.get(opts.command)
++        cmd = cmd_cls(self)
++        try:
++            opts = self.cli.optparser.parse_command_args(cmd, s_line)
++            cmd.cli = self.cli
++            cmd.cli.demands = copy.deepcopy(self.cli.demands)
++            cmd.configure()
++            cmd.run()
++        except:
++            pass
++
++    def PKG_filter(self, packages):
++        strings_pattern_end = ('-dev', '-doc', '-dbg', '-staticdev', '-ptest')
++        notype_pkgs = packages
++        for pkg in packages:
++            if "-locale-" in pkg.name:
++                notype_pkgs.remove(pkg)
++            elif "-localedata-" in pkg.name:
++                notype_pkgs.remove(pkg)
++            elif pkg.name.endswith(strings_pattern_end):
++                notype_pkgs.remove(pkg)
++        return notype_pkgs
++
++    def GET_SOURCE_or_SPDX(self, selected_pkgs):
++        if self.screen != None:
++            StopHotkeyScreen(self.screen)
++            self.screen = None
++        notype_pkgs = self.PKG_filter(selected_pkgs)
++        if self.install_type == ACTION_GET_SOURCE:
++            srcdir_path = os.environ['SRPM_REPO_DIR']
++            destdir_path = os.environ['SRPM_DESTINATION_DIR']
++            fetchSPDXorSRPM('srpm', notype_pkgs, srcdir_path, destdir_path)
++        elif self.install_type == ACTION_GET_SPDX:
++            srcdir_path = os.environ['SPDX_REPO_DIR']
++            destdir_path = os.environ['SPDX_DESTINATION_DIR']
++            fetchSPDXorSRPM('spdx', notype_pkgs, srcdir_path, destdir_path)
++
++    def GET_RKG(self, selected_pkgs):
++        if self.screen != None:
++            StopHotkeyScreen(self.screen)
++            self.screen = None
++        srcdir_path = os.environ['RPM_REPO_DIR']
++        destdir_path = os.environ['RPM_DESTINATION_DIR']
++        fetchSPDXorSRPM('rpm', selected_pkgs, srcdir_path, destdir_path)
++
++    def GET_ALL(self, selected_pkgs):
++        if self.screen != None:
++            StopHotkeyScreen(self.screen)
++            self.screen = None
++        fetchSPDXorSRPM('rpm', selected_pkgs,
++                    os.environ['RPM_REPO_DIR'], os.environ['RPM_DESTINATION_DIR'])
++        notype_pkgs = self.PKG_filter(selected_pkgs)
++        fetchSPDXorSRPM('srpm', notype_pkgs,
++                    os.environ['SRPM_REPO_DIR'], os.environ['SRPM_DESTINATION_DIR'])
++        fetchSPDXorSRPM('spdx', notype_pkgs,
++                    os.environ['SPDX_REPO_DIR'], os.environ['SPDX_DESTINATION_DIR'])
++
++    def Read_ConfigFile(self, display_pkgs, selected_pkgs):
++        f = open(self.CONFIG_FILE, "r")
++        get_text = f.read()
++        config_list = get_text.split('\n')
++
++        for pkg in display_pkgs:
++            if pkg.name in config_list:
++                selected_pkgs.append(pkg)
++        selected_pkgs = list(set(selected_pkgs))
++        f.close()
++        return selected_pkgs
++
++    def Save_ConfigFile(self, selected_pkgs, file_name, mode):
++        save_list = []
++        for pkg in selected_pkgs:
++            save_list.append(pkg.name)
++
++        f = open(file_name, mode)
++        for line in save_list:
++            f.write(line + '\n')
++        f.close()
++
++    def Read_Samples(self):
++        sample_list = []
++        if os.path.isdir(SAMPLE):
++            for (root, dirs, filenames) in os.walk(SAMPLE):
++                filenames.sort()
++                for index in range(len(filenames)):
++                    sample = ("Reference" + str(index+1) + "(" + filenames[index] + " based root file system)", filenames[index] + " based root file system", filenames[index])
++                    sample_list.append(sample)
++            return (True, sample_list)
++        else:
++            return (False, "There is no sample files")
++
++    def PKGINSTDispMain(self):
++        STAGE_INSTALL_TYPE = 1
++        STAGE_CUSTOM_TYPE = 2
++        STAGE_RECORD_INSTALL = 3
++        STAGE_SAMPLE_INSTALL = 4
++        STAGE_PKG_TYPE = 5
++        STAGE_CUST_LIC = 6
++        STAGE_PACKAGE = 7
++        STAGE_PACKAGE_SPEC = 8
++        STAGE_PROCESS = 9
++        STAGE_GROUP = 10
++        STAGE_IMAGE_TYPE = 11
++
++        custom_type = NEW_INSTALL
++        #----dnf part-------
++        try:
++            ypl = self.base.returnPkgLists(
++                self.pkgnarrow, self.patterns, self.installed_available, self.reponame)
++        except dnf.exceptions.Error as e:
++            return 1, [str(e)]
++        else:
++            if len(ypl.available + ypl.installed) < 1:
++                print ("Error! No packages!")
++                sys.exit(0)
++            self.screen = StartHotkeyScreen(_TXT_ROOT_TITLE)
++            if self.screen == None:
++                sys.exit(1)
++            stage = STAGE_INSTALL_TYPE
++
++            def __init_pkg_type():
++                pkgTypeList = []
++
++                pkgType_locale = pkgType("locale", False, "If select, you can see/select *-locale/*-localedata packages in the next step.")
++                pkgTypeList.append(pkgType_locale)
++                pkgType_dev = pkgType("dev", False, "If select, you can see/select *-dev packages in the next step.")
++                pkgTypeList.append(pkgType_dev)
++                pkgType_doc = pkgType("doc", False, "If select, you can see/select *-doc packages in the next step.")
++                pkgTypeList.append(pkgType_doc)
++                pkgType_dbg = pkgType("dbg", False, "If select, you can see/select *-dbg packages in the next step.")
++                pkgTypeList.append(pkgType_dbg)
++                pkgType_staticdev = pkgType("staticdev", False, "If select, you can see/select *-staticdev packages in the next step.")
++                pkgTypeList.append(pkgType_staticdev)
++                pkgType_ptest = pkgType("ptest", False, "If select, you can see/select *-ptest packages in the next step.")
++                pkgTypeList.append(pkgType_ptest)
++
++                return pkgTypeList
++
++            pkgTypeList = __init_pkg_type()
++            selected_pkgs = []
++            selected_pkgs_spec = []
++            pkgs_spec = []
++            #init the samples from sample file
++            (Flag, sample_list) = self.Read_Samples()
++            if Flag == True:
++                for sample in sample_list:
++                    Custom_actions.append(sample)
++
++            while True:
++                #==============================
++                # select install type
++                #==============================
++                if stage == STAGE_INSTALL_TYPE:
++                    self.install_type = PKGINSTActionWindowCtrl(self.screen, Install_actions, self.install_type)
++
++                    if self.install_type == ACTION_INSTALL:
++                        stage = STAGE_CUSTOM_TYPE
++                        continue
++                    elif self.install_type == ACTION_MAKE_IMG:
++                        stage = STAGE_IMAGE_TYPE
++                    else:
++                        stage = STAGE_PACKAGE
++
++                    selected_pkgs = []
++                    selected_pkgs_spec = []
++                    pkgs_spec = []
++                    self.group_botton = False
++
++                # ==============================
++                # custom type
++                # ==============================
++                elif stage == STAGE_CUSTOM_TYPE:
++                    (result, custom_type) = PKGCUSActionWindowCtrl(self.screen, Custom_actions, self.install_type)
++
++                    # Read comps information
++                    self.base.read_comps(arch_filter=True)
++                    self.grps = self.base.comps.groups
++                    if self.grps:
++                        self.group_flag = True #Show hotkey F6
++                        self.group_botton = False #hotkey F6 hasn't been pressed
++
++                    if result == "b":
++                        # back
++                        stage = STAGE_INSTALL_TYPE
++                        continue
++
++                    if custom_type == NEW_INSTALL:
++                        stage = STAGE_PACKAGE
++                        result = HotkeyExitWindow(self.screen, confirm_type=CONFIRM_LICENSE)
++                        if result == "y":
++                            self.no_gpl3 = False
++                        else:
++                            self.no_gpl3 = True
++
++                    # Load Package list install
++                    elif custom_type == RECORD_INSTALL:
++                        stage = STAGE_RECORD_INSTALL
++                        self.no_gpl3 = False
++                    # Load Sample to install
++                    elif custom_type >= SAMPLE_INSTALL:
++                        sample_type = custom_type-2
++                        custom_type = SAMPLE_INSTALL
++                        stage = STAGE_SAMPLE_INSTALL
++                        self.no_gpl3 = False
++
++                # ==============================
++                # record install
++                # ==============================
++                # Load Package list to install
++                elif stage == STAGE_RECORD_INSTALL:
++
++                    (result, self.CONFIG_FILE) = PKGINSTPathInputWindow(self.screen, \
++                                                      True, \
++                                                      "  Package List File  ", \
++                                                      "Enter the name of package list file you wish to load:", \
++                                                      self.CONFIG_FILE )
++
++                    if result == "cancel":
++                        # back
++                        stage = STAGE_CUSTOM_TYPE
++                        continue
++
++                    else:
++                        # next
++                        stage = STAGE_PACKAGE
++
++                # ==============================
++                # sample install
++                # ==============================
++                elif stage == STAGE_SAMPLE_INSTALL:
++                    config_file = SAMPLE + '/' + sample_list[sample_type][2]
++                    try:
++                        f = open(config_file, "r")
++                    except Exception as e:
++                        logger.error(_("%s."), e)
++                        StopHotkeyScreen(self.screen)
++                        self.screen = None
++                        sys.exit(0)
++                    self.CONFIG_FILE = config_file
++                    stage = STAGE_PACKAGE
++
++                #==============================
++                # Grouplist
++                #==============================
++                elif stage == STAGE_GROUP:
++                    group_list = []
++                    for grp in self.grps:
++                        group = (grp.ui_name, grp.ui_description, grp.mandatory_packages)
++                        group_list.append(group)
++
++                    (result, group_id) = PKGCUSActionWindowCtrl(self.screen, group_list, self.install_type, True)
++
++                    if result == "b":
++                        # back
++                        stage = STAGE_CUSTOM_TYPE
++                        continue
++
++                    elif result == "g":
++                        #group
++                        self.group_botton = False
++                        stage = STAGE_PACKAGE
++                        continue
++
++                    else:
++                        pkg_group = group_list[group_id][2]
++                        stage = STAGE_PACKAGE
++
++
++                #==============================
++                # select package
++                #==============================
++                elif stage == STAGE_PACKAGE:
++                    if self.group_flag == True and self.install_type == ACTION_INSTALL:
++                    # Show hotkey F6
++                        if self.group_botton == False:
++                            (result, selected_pkgs, pkgs_spec) = self.PKGINSTWindowCtrl(None, \
++                                                                                None, selected_pkgs, custom_type, pkg_group=[], group_hotkey=True )
++
++                        else:
++                            # Show group interface
++                            (result, selected_pkgs, pkgs_spec) = self.PKGINSTWindowCtrl(None, \
++                                                                                None, selected_pkgs, custom_type, pkg_group)
++                    else:
++                        (result, selected_pkgs, pkgs_spec) = self.PKGINSTWindowCtrl(None, \
++                                                                                None, selected_pkgs, custom_type)
++
++                    if result == "b":
++                        # back
++                        if self.install_type == ACTION_INSTALL:
++                            stage = STAGE_CUSTOM_TYPE
++                        else:
++                            stage = STAGE_INSTALL_TYPE
++                            self.no_gpl3 = False
++
++                        if self.group_botton == True:
++                            stage = STAGE_GROUP
++                        continue
++
++                    if result == "g":
++                        if self.group_flag == True and self.install_type == ACTION_INSTALL:
++                            #group
++                            self.group_botton = True
++                            stage = STAGE_GROUP
++                            continue
++
++                    elif result == "n":
++                        if self.install_type == ACTION_INSTALL:
++                            stage = STAGE_PKG_TYPE
++                        else:
++                            #confirm if or not continue process function
++                            install_type_switch = {ACTION_REMOVE: CONFIRM_REMOVE, \
++                                                   ACTION_UPGRADE: CONFIRM_UPGRADE, \
++                                                   ACTION_GET_PKG: CONFIRM_GET_PKG, \
++                                                   ACTION_GET_SOURCE: CONFIRM_GET_SOURCE, \
++                                                   ACTION_GET_SPDX: CONFIRM_GET_SPDX, \
++                                                   ACTION_GET_ALL: CONFIRM_GET_ALL}
++                            confirm_type = install_type_switch.get(self.install_type)
++
++                            hkey = HotkeyExitWindow(self.screen, confirm_type)
++                            if hkey == "y":
++                                stage = STAGE_PROCESS
++                            elif hkey == "n":
++                                stage = STAGE_PACKAGE
++
++                #==============================
++                # select package type
++                #==============================
++                elif stage == STAGE_PKG_TYPE:
++                    (result, pkgTypeList) = PKGTypeSelectWindowCtrl(self.screen, pkgTypeList)
++                    if result == "b":
++                        # back
++                        stage = STAGE_PACKAGE
++                    elif result == "n":
++                        stage = STAGE_PACKAGE_SPEC
++
++                #==============================
++                # select special packages(local, dev, dbg, doc)
++                #==============================
++                elif stage == STAGE_PACKAGE_SPEC:
++                    (result, selected_pkgs_spec, pkgs_temp) = self.PKGINSTWindowCtrl(pkgTypeList, \
++                                                                                pkgs_spec, selected_pkgs_spec, custom_type)
++                    if result == "b":
++                        # back
++                        stage = STAGE_PKG_TYPE
++                    elif result == "k":
++                        stage = STAGE_PKG_TYPE
++                    elif result == "n":
++                        stage = STAGE_PROCESS
++
++                # ==============================
++                # Select image type
++                # ==============================
++                elif stage == STAGE_IMAGE_TYPE:
++                    state = 0
++                    while state < 3:
++                        # Select Image Type
++                        if state == 0:
++                            (result, self.image_type) = PKGCUSActionWindowCtrl(self.screen, Image_types, self.image_type, title="Select Image type")
++                            if result == "b":
++                                # back
++                                stage = STAGE_INSTALL_TYPE
++                                break
++
++                            insMKIMGInfo = MKIMGInfo(self.image_type)
++
++                        # Setup Configuration
++                        elif state == 1:
++                            #Press ENTER, you can call the corresponding make image function
++                            rcode = Image_type_functions[self.image_type][0](self.screen, insMKIMGInfo)
++                            #retrun button of MKIMGxxxWindowCtrl
++                            if rcode == "b":
++                                # back
++                                state = 0
++                                continue
++
++                        # Confirm
++                        elif state == 2:
++                            # Make Image file name
++                            if os.path.isdir(insMKIMGInfo.get_to_dir_path()):
++                                insMKIMGInfo.set_image_file_name(Image_type_name[self.image_type])
++                            else:
++                            # If you give the abspath of img_patch, no need to set the img_name
++                                (to_dir, img_name) = os.path.split(insMKIMGInfo.get_to_dir_path())
++                                insMKIMGInfo.set_to_dir_path(to_dir)
++                                insMKIMGInfo.set_image_file_name(img_name)
++
++                            # information confirm function
++                            rcode = Image_type_functions[self.image_type][1](self.screen, insMKIMGInfo)
++                            if rcode == "b":
++                                state = 1
++                                continue
++
++                        state = state + 1
++
++                    continue
++
++                # ==============================
++                # Process function
++                # ==============================
++                elif stage == STAGE_PROCESS:
++                    if self.install_type == ACTION_INSTALL:
++                        self.CONFIG_FILE = ".config"
++                        (result, self.CONFIG_FILE) = PKGINSTPathInputWindow(self.screen, \
++                                                      False, \
++                                                      "  Package List File  ", \
++                                                      "Enter the name of package list file you wish to save:", \
++                                                      self.CONFIG_FILE )
++                    if result == "cancel":
++                        # save config file
++                        self.SAVE = False
++
++                    if self.install_type == ACTION_GET_SOURCE or self.install_type == ACTION_GET_SPDX:
++                        self.GET_SOURCE_or_SPDX(selected_pkgs)
++                        break
++                    if self.install_type == ACTION_GET_PKG:
++                        self.GET_RKG(selected_pkgs)
++                        break
++                    if self.install_type == ACTION_GET_ALL:
++                        self.GET_ALL(selected_pkgs)
++                        break
++                    else:
++                        for pkg in selected_pkgs:           #selected_pkgs
++                            if self.install_type == ACTION_INSTALL:
++                                s_line = ["install", pkg.name]
++                            elif self.install_type == ACTION_REMOVE:
++                                s_line = ["remove", pkg.name]
++                            elif self.install_type == ACTION_UPGRADE:
++                                s_line = ["upgrade", pkg.name]
++                            self.run_dnf_command(s_line)
++
++                        if self.install_type == ACTION_INSTALL:
++                            if self.SAVE == True:
++                                self.Save_ConfigFile(selected_pkgs, self.CONFIG_FILE, "w")
++                                #selected_pkgs_spec
++                                if selected_pkgs_spec:
++                                    self.Save_ConfigFile(selected_pkgs_spec, self.CONFIG_FILE, "a")
++
++                            for pkg in selected_pkgs_spec:
++                                s_line = ["install", pkg.name]
++                                self.run_dnf_command(s_line)
++
++                        if self.no_gpl3:
++                            #obtain the transaction
++                            self.base.resolve(self.cli.demands.allow_erasing)
++                            #obtain the deps of selected pkgs
++                            install_set = self.base.transaction.install_set
++
++                            result = self.showChangeSet(install_set)
++                            #continue to install
++                            if result == "y":
++                                if self.install_type == ACTION_INSTALL:
++                                    confirm_type = CONFIRM_INSTALL
++
++                                hkey = HotkeyExitWindow(self.screen, confirm_type)
++
++                                if hkey == "y":
++                                    if self.screen != None:
++                                        StopHotkeyScreen(self.screen)
++                                        self.screen = None
++                                    if self.install_type != ACTION_REMOVE:
++                                        self.base.conf.assumeyes = True
++                                    break
++                                elif hkey == "n":
++                                    stage = STAGE_PKG_TYPE
++                            #don't want to install GPLv3 that depended by others
++                            elif result == "b":
++                                stage = STAGE_PKG_TYPE
++                            elif result == "n":
++                                if self.install_type == ACTION_INSTALL:
++                                    confirm_type = CONFIRM_INSTALL
++
++                                hkey = HotkeyExitWindow(self.screen, confirm_type)
++
++                                if hkey == "y":
++                                    if self.screen != None:
++                                        StopHotkeyScreen(self.screen)
++                                        self.screen = None
++                                    if self.install_type != ACTION_REMOVE:
++                                        self.base.conf.assumeyes = True
++                                    break
++
++                        else:
++                            if self.screen != None:
++                                StopHotkeyScreen(self.screen)
++                                self.screen = None
++                                if self.install_type != ACTION_REMOVE:
++                                    self.base.conf.assumeyes = True
++                            break
++
++            if self.screen != None:
++                StopHotkeyScreen(self.screen)
++                self.screen = None
++
++    def _DeleteUpgrade(self,packages=None,display_pkgs=[]):
++        haveUpgrade=False
++        for i, pkg in enumerate(display_pkgs[:-1]):
++            for pkg_oth in display_pkgs[i+1:]:
++                if pkg.name==pkg_oth.name:
++                    haveUpgrade=True
++                    break
++            if haveUpgrade :
++                break
++        ctn=0
++        if(haveUpgrade):
++            for pkg in packages:
++                if  (not pkg.installed) and (pkg in display_pkgs):
++                    ctn+=1
++                    display_pkgs.remove(pkg)
++        return haveUpgrade
++
++    def PkgType_filter(self, display_pkgs, packages, pkgTypeList):
++        pkgType_dic= dict()
++        Type_status = False
++        for pkgType in pkgTypeList:
++            pkgType_dic[pkgType.name] = pkgType.status
++            if pkgType.status == True:
++                Type_status = True
++
++        if Type_status:
++            #Don't show doc and dbg packages
++            strings_pattern_end = ('-dev', '-doc', '-dbg', '-staticdev', '-ptest')
++            for pkg in packages:
++                if "-locale-" in pkg.name and not pkgType_dic["locale"]:
++                    display_pkgs.remove(pkg)
++                elif "-localedata-" in pkg.name and not pkgType_dic["locale"]:
++                    display_pkgs.remove(pkg)
++                elif pkg.name.endswith(strings_pattern_end):
++                    index = pkg.name.rindex('-')
++                    string_pattern = pkg.name[index+1:]
++                    if not pkgType_dic[string_pattern]:
++                        display_pkgs.remove(pkg)
++
++        else:
++            display_pkgs = []
++
++        return display_pkgs
++
++    def PKGINSTWindowCtrl(self, pkgTypeList, packages=None, selected_pkgs=[], custom_type=0, pkg_group=[], group_hotkey=False):
++        STAGE_SELECT = 1
++        STAGE_PKG_TYPE = 2
++        STAGE_BACK   = 3
++        STAGE_INFO   = 4
++        STAGE_EXIT   = 5
++        STAGE_SEARCH = 6
++        STAGE_NEXT = 7
++        STAGE_GROUP = 8
++
++        iTargetSize = 0
++        iHostSize = 0
++
++        searched_ret = []
++        pkgs_spec = []
++        position = 0
++        search_position = 0
++        check = 0
++        stage = STAGE_SELECT
++        search = None
++
++        hotkey_switch = {"n": STAGE_NEXT, \
++                     "b": STAGE_BACK, \
++                     "i": STAGE_INFO, \
++                     "x": STAGE_EXIT, \
++                     "g": STAGE_GROUP, \
++                     "r": STAGE_SEARCH}
++
++        try:
++            ypl = self.base.returnPkgLists(
++                self.pkgnarrow, self.patterns, self.installed_available, self.reponame)
++        except dnf.exceptions.Error as e:
++            return 1, [str(e)]
++
++        if pkgTypeList == None:
++            pkg_available = copy.copy(ypl.available)
++            pkg_installed = copy.copy(ypl.installed)
++            packages = ypl.installed + ypl.available
++            display_pkgs = pkg_installed + pkg_available
++            sorted(packages)
++            sorted(display_pkgs)
++        else:
++            display_pkgs = copy.copy(packages)
++
++        if self.no_gpl3:
++            for pkg in packages:
++                license = pkg.license
++                if license:
++                    if "GPLv3" in license:
++                        display_pkgs.remove(pkg)
++            packages = copy.copy(display_pkgs) #backup all pkgs
++
++        if pkgTypeList != None:
++            display_pkgs = self.PkgType_filter(display_pkgs, packages, pkgTypeList)
++
++            actions = (ACTION_REMOVE, ACTION_UPGRADE, ACTION_GET_PKG, ACTION_GET_SOURCE, ACTION_GET_SPDX, ACTION_GET_ALL)
++            if self.install_type in actions:
++                for pkg in packages:
++                    if pkg not in ypl.installed:
++                        if pkg in display_pkgs:
++                            display_pkgs.remove(pkg)
++
++            elif self.install_type == ACTION_INSTALL:
++                if(self._DeleteUpgrade(packages,display_pkgs)):
++                    hkey = HotkeyAttentionWindow(self.screen, ATTENTON_HAVE_UPGRADE)
++
++            if len(display_pkgs) == 0:
++                if not self.no_gpl3:
++                    if self.install_type == ACTION_INSTALL     :
++                        confirm_type = CONFIRM_INSTALL
++                        hkey = HotkeyExitWindow(self.screen, confirm_type)
++                        if custom_type >= RECORD_INSTALL:
++                            selected_pkgs = []
++                            selected_pkgs = self.Read_ConfigFile(packages, selected_pkgs)
++                        if hkey == "y":
++                            return ("n", selected_pkgs, packages)
++                        elif hkey == "n":
++                            return ("k", selected_pkgs, packages)
++                    else:
++                        hkey=HotkeyAttentionWindow(self.screen,ATTENTON_NONE)
++                        return ("b", selected_pkgs, packages)
++                else:
++                    return ("n", selected_pkgs, packages)
++        else:
++            #filter the type pkg such as -dev (Round1)
++            if self.install_type == ACTION_INSTALL:
++                strings_pattern_end = ('-dev', '-doc', '-dbg', '-staticdev', '-ptest')
++                for pkg in packages:
++                    if "-locale-" in pkg.name:
++                        display_pkgs.remove(pkg)
++                        pkgs_spec.append(pkg)
++                    elif "-localedata-" in pkg.name:
++                        display_pkgs.remove(pkg)
++                        pkgs_spec.append(pkg)
++                    elif pkg.name.endswith(strings_pattern_end):
++                        display_pkgs.remove(pkg)
++                        pkgs_spec.append(pkg)
++
++                if(self._DeleteUpgrade(packages,display_pkgs)):
++                    hkey = HotkeyAttentionWindow(self.screen, ATTENTON_HAVE_UPGRADE)
++
++                if self.group_flag == True and self.group_botton == True:
++                    groupinfo = []
++                    for pkg in pkg_group:
++                       groupinfo.append(pkg.name)
++                    display_pkgs = []
++                    for pkg in packages:
++                       if pkg.name in groupinfo:
++                           display_pkgs.append(pkg)
++
++            #Except install
++            else:
++                for pkg in packages:
++                    if pkg not in ypl.installed:
++                        if pkg in display_pkgs:
++                            display_pkgs.remove(pkg)
++                display_pkgs = sorted(display_pkgs)
++
++            if self.install_type == ACTION_UPGRADE:
++                q = self.base.sack.query()
++                upgrade_set = q.upgrades()
++
++                display_pkgs = []
++                for pkg in upgrade_set:
++                    display_pkgs.append(pkg)
++                display_pkgs = sorted(display_pkgs)
++
++        if len(display_pkgs)==0:
++            if self.install_type==ACTION_INSTALL:
++                stage = STAGE_NEXT
++            elif self.install_type==ACTION_UPGRADE:
++                hkey = HotkeyAttentionWindow(self.screen, ATTENTON_NONE_UPGRADE)
++                return ("b", selected_pkgs, packages)
++            else:
++                hkey = HotkeyAttentionWindow(self.screen, ATTENTON_NONE)
++                return ("b", selected_pkgs, packages)
++
++        if custom_type >= RECORD_INSTALL:
++            selected_pkgs = []
++            selected_pkgs = self.Read_ConfigFile(display_pkgs, selected_pkgs)
++
++        while True:
++            if stage == STAGE_SELECT:
++                if search == None:
++                    (hkey, position, pkglist) = PKGINSTPackageWindow(self.screen, \
++                                                            display_pkgs, \
++                                                            selected_pkgs, \
++                                                            position, \
++                                                            iTargetSize, \
++                                                            iHostSize, \
++                                                            search, \
++                                                            self.install_type, group_hotkey)
++                else:
++                    (hkey, search_position, pkglist) = PKGINSTPackageWindow(self.screen, \
++                                                             searched_ret, \
++                                                             selected_pkgs, \
++                                                             search_position, \
++                                                             iTargetSize, \
++                                                             iHostSize, \
++                                                             search, \
++                                                             self.install_type, group_hotkey)
++
++                stage = hotkey_switch.get(hkey, None)
++
++            elif stage == STAGE_NEXT:
++                search = None
++                #if in packages select Interface:
++                if pkgTypeList == None:
++                    return ("n", selected_pkgs, pkgs_spec)
++                #if in special type packages(dev,doc,locale) select Interface:
++                else:
++                    if not self.no_gpl3:
++                        if self.install_type == ACTION_INSTALL : confirm_type = CONFIRM_INSTALL
++
++                        hkey = HotkeyExitWindow(self.screen, confirm_type)
++                        if hkey == "y":
++                            return ("n", selected_pkgs, packages)
++                        elif hkey == "n":
++                            stage = STAGE_SELECT
++                    else:
++                        return ("n", selected_pkgs, packages)
++            elif stage == STAGE_BACK:
++                if not search == None:
++                    stage = STAGE_SELECT
++                    search = None
++                else:
++                    return ("b", selected_pkgs, pkgs_spec)
++            elif stage == STAGE_GROUP:
++                if not search == None:
++                    stage = STAGE_SELECT
++                    search = None
++                else:
++                    return ("g", selected_pkgs, pkgs_spec)
++            elif stage == STAGE_INFO:
++                if not search == None:
++                    PKGINSTPackageInfoWindow(self.screen, searched_ret[search_position])
++                else:
++                    PKGINSTPackageInfoWindow(self.screen, display_pkgs[position])
++                stage = STAGE_SELECT
++            elif stage == STAGE_EXIT:
++                hkey = HotkeyExitWindow(self.screen)
++                if hkey == "y":
++                    if self.screen != None:
++                        StopHotkeyScreen(self.screen)
++                        self.screen = None
++                    sys.exit(0)
++                elif hkey == "n":
++                    stage = STAGE_SELECT
++            elif stage == STAGE_SEARCH:
++                search_position = 0
++                search = PKGINSTPackageSearchWindow(self.screen)
++                if not search == None:
++                    def __search_pkgs(keyword, pkgs):
++                        searched_pgks = []
++                        keyword = re.escape(keyword)
++                        for pkg in pkgs:
++                            if re.compile(keyword, re.IGNORECASE).search(pkg.name):
++                                searched_pgks.append(pkg)
++                        return searched_pgks
++                    searched_ret = __search_pkgs(search, display_pkgs)
++                    if len(searched_ret) == 0:
++                        buttons = ['OK']
++                        (w, h) = GetButtonMainSize(self.screen)
++                        rr = ButtonInfoWindow(self.screen, "Message", "%s - not found." % search, w, h, buttons)
++                        search = None
++                stage = STAGE_SELECT
++
++    def showChangeSet(self, pkgs_set):
++        gplv3_pkgs = []
++        #pkgs = self.opts.pkg_specs
++        for pkg in pkgs_set:
++            license = pkg.license
++            if license:
++                if "GPLv3" in license:
++                    gplv3_pkgs.append(pkg)
++        if len(gplv3_pkgs) > 0:
++            hkey = ConfirmGplv3Window(self.screen, gplv3_pkgs)
++            if hkey == "b":
++                return "b"
++            elif hkey == "n":
++                return "n"
++        else:
++            return "y"
+diff --git a/dnf-plugins/utils.py b/dnf-plugins/utils.py
+new file mode 100755
+index 0000000..6b6c9b3
+--- /dev/null
++++ b/dnf-plugins/utils.py
+@@ -0,0 +1,182 @@
++# Copyright (C) 2016  Red Hat, Inc.
++#
++# This program is free software; you can redistribute it and/or modify
++# it under the terms of the GNU General Public License as published by
++# the Free Software Foundation; either version 2 of the License, or
++# (at your option) any later version.
++#
++# This program is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU Library General Public License for more details.
++#
++# You should have received a copy of the GNU General Public License
++# along with this program; if not, write to the Free Software
++# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
++
++"""Various utility functions, and a utility class."""
++
++from dnf.cli.format import format_number
++from dnf.i18n import _
++import dnf.util
++import logging
++import os
++import time
++import re, shutil, urllib.request, librepo, filecmp
++
++_USER_HZ = os.sysconf(os.sysconf_names['SC_CLK_TCK'])
++logger = logging.getLogger('dnf')
++
++def read_environ(file):
++    try:
++        with open(file, 'r') as fd:
++            lines = fd.readlines()
++            for line in lines:
++                env = line.rstrip().split('=', 1)
++                os.environ[env[0]] = env[1]
++    except IOError:
++        logger.info(_('Error: Cannot open %s for reading'), self.base.output.term.bold(file))
++        sys.exit(1)
++
++def PKG_filter(packages):
++    strings_pattern_end = ('-dev', '-doc', '-dbg', '-staticdev', '-ptest')
++    notype_pkgs = packages
++    for pkg in packages:
++        if "-locale-" in pkg.name:
++            notype_pkgs.remove(pkg)
++        elif "-localedata-" in pkg.name:
++            notype_pkgs.remove(pkg)
++        elif pkg.name.endswith(strings_pattern_end):
++            notype_pkgs.remove(pkg)
++    return notype_pkgs
++
++def fetchSPDXorSRPM(option, install_pkgs, srcdir_path, destdir_path):
++    """Add for spdx/srpm file cp operation.
++
++    :param option: the file type to be fetch sdpx/srpm.
++    :param install_pkgs: The pkgs objexts which will be installed.
++    :param srcdir_path:  the repo path of source pkg.
++    :param destdir_path:  the destination path of where you want to put your spdx/srpm files.
++    :return: No
++    """
++
++    def find_dir(dir_path, file_name):
++        for (root, dirs, filenames) in os.walk(dir_path):
++            if file_name in filenames:
++                found_path = root + '/' + file_name
++                return found_path
++            else:
++                for dir in dirs:
++                    find_dir(root + '/' + dir, file_name)
++
++    def copy_package(option, pkgname):
++        #src_path = srcdir_path + '/' + pkgname
++        src_path = None
++        src_path = find_dir(srcdir_path, pkgname)
++        dest_path = destdir_path + '/' + pkgname
++
++        if src_path:
++            if os.path.exists(dest_path) and filecmp.cmp(src_path,dest_path):
++                logger.info(_("%s already exists."), pkgname)
++                return
++            try:
++                shutil.copyfile(src_path, dest_path)
++                logger.info(_("%s copy is OK."), pkgname)
++            except Exception as e:
++                logger.error(_("%s."), e)
++                return
++        else:
++            logger.warning(_("%s file: %s does not exist....."), option, pkgname)
++            return
++
++    def http_download_file(option, pkgname):
++        url = srcdir_path + '/' + pkgname
++        file_name = destdir_path + '/' + pkgname
++
++        try:
++            """Example of the simplest usage"""
++            fd = os.open(file_name, os.O_RDWR|os.O_CREAT|os.O_TRUNC)
++            librepo.download_url(url, fd)
++            os.close(fd)
++            logger.info(_("%s http download is OK."), pkgname)
++        except librepo.LibrepoException as e:
++            logger.error(_("%s."), e.args[1])
++            os.remove(file_name)
++            return
++
++    def ftp_download_file(option, pkgname):
++        from ftplib import FTP
++        ip = srcdir_path.split('/')[0]
++        ftp_path = srcdir_path.replace(ip,'/pub')  + '/' + pkgname
++        file_name = destdir_path + '/' + pkgname
++
++        try:
++            ftp=FTP()
++            ftp.connect(ip) #connect to the ftp server
++            ftp.login('','') #login anonymous
++
++            bufsize = 1024 #set the buf size
++            file_handler = open(file_name,'wb').write #open the local file
++            ftp.retrbinary('RETR ' + ftp_path,file_handler,bufsize) #receive the file from ftp server
++            logger.info(_("%s ftp download is OK."), pkgname)
++            ftp.quit() #quit the ftp server
++        except Exception as e:
++            logger.error(_("%s."), e)
++            return
++
++    def fetch_package(option, type, pkgname):
++        if type == 'local':
++            copy_package(option, pkgname)
++        elif type == 'remote_http':
++            http_download_file(option, pkgname)
++        elif type == 'remote_ftp':
++            ftp_download_file(option, pkgname)
++
++    def local_path_check(path):
++        if not os.path.exists(path):
++            logger.error(_("local_repodir %s is not exists, please check it."), path)
++            return
++        else:
++            return True
++
++    #Start from here
++    srcdir_path = "".join(tuple(srcdir_path))  #transfer a list to string
++    '''local fetch'''
++    if srcdir_path.startswith('file://') or srcdir_path.startswith('/'):
++        type = 'local'
++        if srcdir_path.startswith('file://'):
++            srcdir_path = dnf.util.strip_prefix(srcdir_path, 'file://')
++        if not local_path_check(srcdir_path):
++            return
++    elif srcdir_path.startswith('http://'):  ##remote fetch
++        type = 'remote_http'
++    elif srcdir_path.startswith('ftp://'):  ##remote fetch
++        type = 'remote_ftp'
++        srcdir_path = dnf.util.strip_prefix(srcdir_path, 'ftp://')
++    else:
++        logger.error(_("The format of %s_repodir is not right, please check it!\nWe only support file:// and http://"), option)
++        return
++
++    '''when the destdir_path is not exist, make it'''
++    if not os.path.exists(destdir_path):
++        try:
++            os.mkdir(destdir_path)
++        except Exception as e:
++            logger.error(_("Create dir failed, %s."), e)
++            return
++
++    for pkg in sorted(install_pkgs):
++        sourcerpm = pkg.sourcerpm
++        if option == 'spdx':
++            if "-locale" in sourcerpm:
++                sourcerpm = sourcerpm.replace('-locale', '')
++            match = ''.join(re.findall("-r\d{1,}.src.rpm",sourcerpm))
++            '''filter the .src.rpm and r*'''
++            spdxname = sourcerpm.replace(match, '') + ".spdx"
++            fetch_package(option, type, spdxname)
++        elif option == 'srpm':
++            fetch_package(option, type, sourcerpm)
++        elif option == 'rpm':
++            rpm_name = pkg.name+"-"+pkg.version+"-"+pkg.release+"."+pkg.arch+".rpm"
++            fetch_package(option, type, rpm_name)
++
+diff --git a/dnf-plugins/window.py b/dnf-plugins/window.py
+new file mode 100755
+index 0000000..7d06fb2
+--- /dev/null
++++ b/dnf-plugins/window.py
+@@ -0,0 +1,1567 @@
++#encoding=utf-8
++#
++# Copyright (C) 2016 FUJITSU LIMITED
++#
++import sys, os, copy, textwrap, snack, string, time, re
++from snack import *
++from dnf.cli.format import *
++
++ACTION_INSTALL    = 0
++ACTION_REMOVE     = 1
++ACTION_UPGRADE    = 2
++ACTION_GET_PKG    = 3
++ACTION_GET_SOURCE = 4
++ACTION_GET_SPDX   = 5
++ACTION_GET_SPDX   = 6
++
++
++Confirm_type_list = [("Exit","\n Do you really want to terminate it?\n\n"), \
++                     ("Confirm install","\n Do you want to begin installation?\n\n"), \
++                     ("License","\n Do you want to display GPLv3 packages?\n\n"), \
++                     ("Confirm remove","\n Do you want to begin removing?\n\n"), \
++                     ("Confirm upgrade","\n Do you want to begin upgrading?\n\n"), \
++                     ("Confirm get package","\n Begin getting package archive?\n\n"), \
++                     ("Confirm get source","\n Begin getting source archive?\n\n"), \
++                     ("Confirm get SPDX","\n Begin getting SPDX archive?\n\n"), \
++                     ("Confirm get ALL","\n Begin getting all archive?\n\n") \
++                     ]
++
++Attention_type_list=[("Attention!","\n You must installed some packages first!\n\n"), \
++                     ("Attention!","Have some advanced version packages.\nShow installed only!\n\
++You can enter 'upgrade' scene to upgrade \ninstalled packages.\n"), \
++                     ("Attention!","\n There is no package to be upgraded!\n\n") \
++                     ]
++
++SIGN_SELECT=["*", "-", "U", "R", "S", "S", "A"]
++
++class pkgType:
++    name = None
++    status = None
++    description = None
++
++    def __init__(self, type, status, desc):
++        self.name = type
++        self.status = False
++        self.description = desc
++
++#------------------------------------------------------------
++# def GetWindowSize()
++#
++#   Get Window size.
++#
++# Input:
++#   insScreen : screen instance
++# Output:
++#   int       : window height
++#   int       : window width
++#------------------------------------------------------------
++def GetWindowSize(insScreen):
++    return (insScreen.width, insScreen.height)
++
++#------------------------------------------------------------
++# def GetHotkeyMainSize()
++#
++#   Get best full screen main object size for HotKey mode
++#
++# Input:
++#   insScreen : screen instance
++# Output:
++#   int       : width
++#   int       : height
++#------------------------------------------------------------
++def GetHotKeyMainSize(insScreen):
++    (width, height) = GetWindowSize(insScreen)
++
++    width -= 8
++
++    # It is not centered well only by doing -9 when the Height is an Odd.
++    # In addition, it is necessary to do 1.
++    height -= (9 - (height % 2))
++
++    return (width, height)
++#------------------------------------------------------------
++# def _StatusToggle(insLi, sHkey, iIdx, selected_packages, packages, install_type)
++#
++#   package select window, "selection" function.
++#
++# Input:
++#    insLi              : instance of Listbox
++#    sHkey              : hotkey selected
++#    iIdx               : index selected
++#    selected_packages  : selected_package
++#    packages           : display packages
++#    install_type       :INSTALL or REMOVE or UPDATE
++# Output:
++#    packages : showed packages
++#------------------------------------------------------------
++
++def _StatusToggle(insLi, sHkey, iIdx, selected_packages, packages, install_type):
++    pkg = packages[iIdx]
++    #print "select package : %s " % pkg.name
++    if sHkey == " " or sHkey == "ENTER":
++        if install_type == ACTION_INSTALL and (not pkg.installed):
++            if pkg in selected_packages:
++                selected_packages.remove(pkg)
++                newsign = " "
++            else:
++                selected_packages.append(pkg)
++                newsign = SIGN_SELECT[install_type]
++        elif not install_type == ACTION_INSTALL:
++            if pkg in selected_packages:
++                selected_packages.remove(pkg)
++                newsign = " "
++            else:
++                selected_packages.append(pkg)
++                newsign = SIGN_SELECT[install_type]
++        else:
++            return insLi
++    item = "[%s] %s" % (newsign, pkg.name)
++    insLi.replace(item, iIdx)
++    return insLi
++#------------------------------------------------------------
++# def _SelectAll(insLi, sHkey,numPackage,selected_packages, packages, install_type))
++#
++#   package select window, "select all" function.
++#
++# Input:
++#    insLi             : instance of Listbox
++#    sHkey             : hotkey selected
++#    numPackage        : number of showed packages
++#    selected_packages : selected_package
++#    packages          : showed packages
++#    install_type      : INSTALL or REMOVE or UPDATE
++# Output:
++#    insLi :changed instance of Listbox
++#------------------------------------------------------------
++def _SelectAll(insLi, sHkey, numPackage, selected_packages, packages, \
++                                                       install_type):
++    haveSelected=False
++    for pkg in packages:
++        if (not pkg in selected_packages) and ((install_type==ACTION_INSTALL and (not pkg.installed))or \
++                                                                    not install_type==ACTION_INSTALL):
++            haveSelected=True
++            break
++
++#replace sign in list
++
++    if install_type == ACTION_INSTALL:
++        if haveSelected :
++            for iIdx in range(0,numPackage):
++                pkg=packages[iIdx]
++                if (not pkg in selected_packages) and (not pkg.installed):
++                    selected_packages.append(pkg)
++                    item = "[%s] %s" % (SIGN_SELECT[install_type], pkg.name)
++                    insLi.replace(item,iIdx)
++        else:
++            for iIdx in range(0,numPackage):
++                pkg=packages[iIdx]
++                if (pkg in selected_packages) and (not pkg.installed):
++                    selected_packages.remove(pkg)
++                    item = "[%s] %s" % (" ", pkg.name)
++                    insLi.replace(item,iIdx)
++
++    else:
++        if haveSelected :
++            for iIdx in range(0,numPackage):
++                pkg=packages[iIdx]
++                if not pkg in selected_packages:
++                    selected_packages.append(pkg)
++                    item = "[%s] %s" % (SIGN_SELECT[install_type], pkg.name)
++                    insLi.replace(item,iIdx)
++        else:
++            for iIdx in range(0,numPackage):
++                pkg=packages[iIdx]
++                if pkg in selected_packages:
++                    selected_packages.remove(pkg)
++                    item = "[%s] %s" % (" ", pkg.name)
++                    insLi.replace(item,iIdx)
++
++    return insLi
++
++#_SelectAll
++
++
++#------------------------------------------------------------
++# def StartHotkeyScreen()
++#
++#   Setup snack's screen and hotkey dict for Hotkey mode.
++#
++# Input:
++#   sText : root text
++# Output:
++#   ins   : screen instance
++#------------------------------------------------------------
++def StartHotkeyScreen(sText):
++
++    # Set screen mode
++    os.environ['NEWT_MONO'] = "1"
++    env_term = os.getenv("TERM").upper()
++    if env_term == "VT100":
++        print ("\x1b[?25l")  # cursor off
++
++    # Setup hotkey dictionary
++    for x in string.ascii_letters:
++        snack.hotkeys[x] = ord(x)
++        snack.hotkeys[ord(x)] = x
++    snack.hotkeys["ENTER"] = 0x0d
++    snack.hotkeys[0x0d] = "ENTER"
++    snack.hotkeys["PD"] = 0x800c
++    snack.hotkeys[0x800c] = "PD"
++
++
++    # Start snack's screen
++    screen = snack.SnackScreen()
++
++    #obtain the width  of screen to calculate the left value for drawRootText=
++    (width, height) = GetWindowSize(screen)
++    Left_Length = (width - len(sText))/2
++
++    screen.drawRootText(int(Left_Length), 0, sText)
++    screen.pushHelpLine(" ")
++
++    # Window size check
++    if width < 80 or height < 24:
++        StopHotkeyScreen(screen)
++        screen = None
++        print ("Your screen is too small! It must be at least 24 lines by 80 columns!")
++
++    return screen
++
++#------------------------------------------------------------
++# def HotkeyExitWindow(insScreen, confirm_install=False)
++#
++#   Display "Exit" window and exit for Hotkey mode.
++#
++# Input:
++#   insScreen : screen instance
++#   confirm_install=False : just exit without install
++#   confirm_install=False : just exit and begin to install
++# Output:
++#   int       : "y" or "n"
++#------------------------------------------------------------
++def HotkeyExitWindow(insScreen, confirm_type=0):
++
++    # Display Exit Window
++    myhotkeys = {"Y" : "y", \
++                 "y" : "y", \
++                 "N" : "n", \
++                 "n" : "n"}
++
++    result = HotkeyInfoButtonWindow(insScreen, Confirm_type_list[confirm_type][0], \
++                 Confirm_type_list[confirm_type][1], \
++                 40, 4, myhotkeys, "Y:yes  N:no")
++
++    return result
++
++
++# ------------------------------------------------------------
++# def HotkeyAttentionWindow(insScreen, confirm_install=False)
++#
++#   Display "Attention" window .
++#
++# Input:
++#   insScreen : screen instance
++#   attention_type: index of  attention text list
++# Output:
++#   int       : "ok"
++# ------------------------------------------------------------
++def HotkeyAttentionWindow(insScreen, attention_type):
++    # Display Exit Window
++    myhotkeys = {"ENTER": "y", \
++                 " ": "y" \
++                }
++
++    result = HotkeyInfoWindow(insScreen, Attention_type_list[attention_type][0], \
++                              Attention_type_list[attention_type][1], \
++                              40, 4, myhotkeys, "Enter/Space:OK")
++
++    return result
++
++
++#------------------------------------------------------------
++# def StopHotkeyScreen()
++#
++#   Finish snack's screen
++#
++# Input:
++#   insScreen : screen instance
++# Output:
++#   None
++#------------------------------------------------------------
++def StopHotkeyScreen(insScreen):
++
++    # Finish Snack's screen
++    insScreen.finish()
++
++    # Resume screen mode
++    env_term = os.getenv("TERM").upper()
++    if env_term == "VT100":
++        print ("\x1b[?25h")  # cursor on
++
++#------------------------------------------------------------
++# def HotkeyInfoWindow()
++#
++#   Display information window for Hotkey mode.
++#
++# Input:
++#   insScreen             : screen instance
++#   sTitle                : title string
++#   sText                 : main text
++#   iWidth                : width of main text
++#   iHeight               : height of main text
++#   dctHotkeys{str : srr} : Hotkey dictionary
++#                           [hotkey string, rtncode]
++#   sHtext                : Hotkey information text
++# Output:
++#   str : rtncode in Hotkey dictionary
++#------------------------------------------------------------
++def HotkeyInfoWindow(insScreen, sTitle, sText, iWidth, iHeight, \
++                     dctHotkeys, sHtext):
++
++    # Get line number
++    length = len(sText)
++    index = 0
++    count = 0
++    scroll = 0
++    while index < length:
++        if sText[index] == "\n":
++            count += 1
++            if count > iHeight:
++                scroll = 1
++                break
++        index += 1
++
++    # Create Text instance
++    t1 = snack.Textbox(iWidth - scroll * 2, iHeight, sText, scroll)
++    t2 = snack.Textbox(iWidth, 1, "-" * iWidth)
++    t3 = snack.Textbox(iWidth, 1, sHtext)
++
++    # Create Grid instance
++    g = snack.GridForm(insScreen, sTitle, 1, 3)
++    g.add(t1, 0, 0)
++
++    insScreen.pushHelpLine("  "+sHtext)
++
++    for x in dctHotkeys.keys():
++        g.addHotKey(x)
++    # Display window
++    while True:
++        result = g.run()
++        if result in dctHotkeys:
++            break
++
++    # Return
++    insScreen.popHelpLine()
++    insScreen.popWindow()
++    return dctHotkeys[result]
++
++#------------------------------------------------------------
++# def HotkeyInfoButtonWindow()
++#
++#   Display information window for Hotkey mode.
++#
++# Input:
++#   insScreen             : screen instance
++#   sTitle                : title string
++#   sText                 : main text
++#   iWidth                : width of main text
++#   iHeight               : height of main text
++#   dctHotkeys{str : srr} : Hotkey dictionary
++#                           [hotkey string, rtncode]
++#   sHtext                : Hotkey information text
++# Output:
++#   str : rtncode in Hotkey dictionary
++#------------------------------------------------------------
++def HotkeyInfoButtonWindow(insScreen, sTitle, sText, iWidth, iHeight, \
++                     dctHotkeys, sHtext):
++
++    # Get line number
++    length = len(sText)
++    index = 0
++    count = 0
++    scroll = 0
++    while index < length:
++        if sText[index] == "\n":
++            count += 1
++            if count > iHeight:
++                scroll = 1
++                break
++        index += 1
++
++    # Create Text instance
++    t1 = snack.Textbox(iWidth - scroll * 2, iHeight, sText, scroll)
++    t2 = snack.Textbox(iWidth, 1, "-" * iWidth)
++    t3 = snack.Textbox(iWidth, 1, sHtext)
++
++    b = snack.ButtonBar(insScreen,((" Yes ", "y"), (" No ", "n")))
++
++    # Create Grid instance
++    g = snack.GridForm(insScreen, sTitle, 1, 4)
++    g.add(t1, 0, 0)
++    g.add(t2, 0, 1, (-1, 0, -1, 0))
++    g.add(b, 0, 2, (1, 0, 1, -1))
++
++    # Display window
++    result = g.run()
++
++    # Return
++    insScreen.popWindow()
++
++    if b.buttonPressed(result) == "y":
++       return 'y'
++    elif b.buttonPressed(result) == "n":
++       return 'n'
++
++#------------------------------------------------------------
++# def PKGINSTTypeInfoWindow()
++#
++#   Display install type information window.
++#
++# Input:
++#   insScreen    : screen instance
++#   sSubject     : install type subject
++#   sDescription : description about the install type
++#   Infotitle    : description of title
++# Output:
++#   None
++#------------------------------------------------------------
++def PKGINSTTypeInfoWindow(insScreen, sSubject, sDescription, titleDescription="Install type information"):
++
++    # Create Main Text
++    (main_width, main_height) = GetHotKeyMainSize(insScreen)
++
++    wrapper = textwrap.TextWrapper(width = main_width - 2)
++
++    wrapper.initial_indent    = ""
++    wrapper.subsequent_indent = ""
++    main_text = wrapper.fill("[ %s ]" % sSubject) + "\n"
++
++    wrapper.initial_indent    = "  "
++    wrapper.subsequent_indent = "  "
++    main_text += (wrapper.fill(sDescription) + "\n\n")
++
++    # Display information window
++    HotkeyInfoWindow(insScreen, titleDescription, main_text, \
++                     main_width, main_height, {"F4" : "b"}, "F4:Back")
++
++#------------------------------------------------------------
++# def PKGINSTTypeWindowCtrl()
++#
++#    Select install type
++#
++# Input:
++#    insScreen         : screen instance
++#    insPKGINSTXmlinfo : xml information
++#    insPKGINSTPkginfo : package information
++#    iType             : select type (first -1)
++#
++# Output:
++#    int  : select type
++#------------------------------------------------------------
++def PKGINSTTypeWindowCtrl(insScreen, lstSubject, iType):
++
++    type = iType
++
++    while True:
++        (hkey, type) = PKGINSTTypeWindow(insScreen, lstSubject, type)
++
++        if hkey == "ENTER" or hkey == " ":
++            # select/unselect
++            return type
++
++        elif hkey == "i":
++            # info
++            description = lstSubject[type][1]
++            subject = lstSubject[type][0]
++            PKGINSTTypeInfoWindow(insScreen, subject, description)
++
++        elif hkey == "x":
++            # exit
++            exit_hkey = HotkeyExitWindow(insScreen)
++            if exit_hkey == "y":
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++                sys.exit(0)
++
++#------------------------------------------------------------
++# def PKGINSTTypeWindow()
++#
++#   Display install type select window.
++#
++# Input:
++#   insScreen  : screen instance
++#   lstSubject : install type subject list
++#      [ str ]
++#        str : subject of each install type
++#   iPosition  : current entry position
++# Output:
++#   str   : pressed hotkey "ENTER", " ", "i", or "x"
++#   int   : position
++#------------------------------------------------------------
++def PKGINSTTypeWindow(insScreen, lstSubject, iPosition):
++
++    # Create CheckboxTree instance
++    (main_width, main_height) = GetHotKeyMainSize(insScreen)
++
++    if len(lstSubject) > main_height:
++        scroll = 1
++    else:
++        scroll = 0
++
++    li = snack.Listbox(main_height, scroll = scroll, width = main_width)
++
++    idx = 0
++    for idx in range(len(lstSubject)):
++        str = "%s" % lstSubject[idx][0]
++        li.append(str+"  --->", idx)
++
++    num_subject = len(lstSubject)
++    if num_subject > iPosition:
++        li.setCurrent(iPosition)
++    else:
++        li.setCurrent(num_subject - 1)
++    # Create Text instance
++    t1 = snack.Textbox(main_width, 1, "-" * main_width)
++    text = "  F5:Info  F9:Exit"
++    t2 = snack.Textbox(main_width, 1, text)
++
++    # Create Grid instance
++    g = snack.GridForm(insScreen, "Select install type", 1, 3)
++    g.add(li, 0, 0)
++    g.add(t1, 0, 1, (-1, 0, -1, 0))
++    g.add(t2, 0, 2, (0, 0, 0, -1))
++
++    myhotkeys = {"ENTER" : "ENTER", \
++                 " "     : " ", \
++                 "F5"     : "i", \
++                 "F9"     : "x"}
++    for x in myhotkeys.keys():
++        g.addHotKey(x)
++
++    # Display window
++    while True:
++        result = g.run()
++        if result in myhotkeys:
++            idx = li.current()
++            break
++
++    insScreen.popWindow()
++    return (myhotkeys[result], idx)
++#------------------------------------------------------------
++# def PKGINSTActionWindowCtrl()
++#
++#    Select install type
++#
++# Input:
++#    insScreen         : screen instance
++#    insPKGINSTXmlinfo : xml information
++#    insPKGINSTPkginfo : package information
++#    iType             : select type (first -1)
++#    title             : title of grid, transmit to PKGINSTActionWindow
++#
++# Output:
++#    int  : select type
++#------------------------------------------------------------
++def PKGINSTActionWindowCtrl(insScreen, lstSubject, iType, title=None):
++
++    type = iType
++
++    while True:
++        if title:
++            (hkey, type) = PKGINSTActionWindow(insScreen, lstSubject, type, title)
++        else:
++            (hkey, type) = PKGINSTActionWindow(insScreen, lstSubject, type)
++
++        if hkey == "ENTER" or hkey == " ":
++            # select/unselect
++            return type
++
++        elif hkey == "i":
++            # info
++            description = lstSubject[type][1]
++            subject = lstSubject[type][0]
++            if len(lstSubject[type])>2:
++                #if title is userdefined, show it
++                PKGINSTTypeInfoWindow(insScreen, subject, description, lstSubject[type][2])
++            else:
++                PKGINSTTypeInfoWindow(insScreen, subject, description)
++
++        elif hkey == "x":
++            # exit
++            exit_hkey = HotkeyExitWindow(insScreen)
++            if exit_hkey == "y":
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++                sys.exit(0)
++
++#------------------------------------------------------------
++# def PKGINSTActionWindow()
++#
++#   Display action select window.
++#
++# Input:
++#   insScreen  : screen instance
++#   lstSubject : install type subject list
++#      [ str ]
++#        str : subject of each install type
++#   iPosition  : current entry position
++#   title             : title of grid
++# Output:
++#   str   : pressed hotkey "ENTER", " ", "i", or "x"
++#   int   : position
++#------------------------------------------------------------
++def PKGINSTActionWindow(insScreen, lstSubject, iPosition, title="Select your operation"):
++
++    # Create CheckboxTree instance
++    (main_width, main_height) = GetHotKeyMainSize(insScreen)
++
++    if len(lstSubject) > main_height:
++        scroll = 1
++    else:
++        scroll = 0
++
++    li = snack.Listbox(main_height, scroll = scroll, width = main_width)
++
++    idx = 0
++    for idx in range(len(lstSubject)):
++        str = "%s" % lstSubject[idx][0]
++        li.append(str+"  --->", idx)
++
++    num_subject = len(lstSubject)
++    if num_subject > iPosition:
++        li.setCurrent(iPosition)
++    else:
++        li.setCurrent(num_subject - 1)
++    # Create Text instance
++    t1 = snack.Textbox(main_width, 1, "-" * main_width)
++    text = "  F5:Info  F9:Exit" + "\n Fffff"
++    t2 = snack.Textbox(main_width, 1, text)
++
++    # Create Grid instance
++    g = snack.GridFormHelp(insScreen, title, "F1", 1, 5)
++    insScreen.pushHelpLine(text)
++    g.add(li, 0, 0, (0, 0, 0, 0))
++
++    myhotkeys = {"ENTER" : "ENTER", \
++                 " "     : " ", \
++                 "F5"     : "i", \
++                 "F9"     : "x"}
++    for x in myhotkeys.keys():
++        g.addHotKey(x)
++
++    # Display window
++    while True:
++        result = g.run()
++        if result in myhotkeys:
++            idx = li.current()
++            break
++
++    #return
++    insScreen.popHelpLine()
++    insScreen.popWindow()
++    return (myhotkeys[result], idx)
++
++# ------------------------------------------------------------
++# def PKGCUSActionWindowCtrl()
++#
++#    Select install type
++#
++# Input:
++#    insScreen         : screen instance
++#    insPKGINSTXmlinfo : xml information
++#    insPKGINSTPkginfo : package information
++#    iType             : select type (first -1)
++#    group_hotkey      : group_hotkey
++#    title             : title of grid
++# Output:
++#    int  : select type
++# ------------------------------------------------------------
++def PKGCUSActionWindowCtrl(insScreen, lstSubject, iType, group_hotkey=False, title=None):
++
++    type = iType
++
++    while True:
++        if title:
++            (hkey, type) = PKGCUSActionWindow(insScreen, lstSubject, type, group_hotkey, title)
++        else:
++            (hkey, type) = PKGCUSActionWindow(insScreen, lstSubject, type, group_hotkey)
++
++        if hkey == "b" :
++            # back
++            return (hkey, type)
++
++        if hkey == "ENTER" or hkey == " ":
++            # select/unselect
++            return (hkey, type)
++
++        elif hkey == "i":
++            # info
++            description = lstSubject[type][1]
++            subject = lstSubject[type][0]
++            if len(lstSubject[type])>2:
++                #if title is userdefined, show it
++                PKGINSTTypeInfoWindow(insScreen, subject, description, lstSubject[type][2])
++            else:
++                PKGINSTTypeInfoWindow(insScreen, subject, description)
++
++        elif hkey == "x":
++            # exit
++            exit_hkey = HotkeyExitWindow(insScreen)
++            if exit_hkey == "y":
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++                sys.exit(0)
++
++        if group_hotkey == True:
++            if hkey == "g":
++                # groupinfo switch
++                return (hkey, type)
++
++
++# ------------------------------------------------------------
++# def PKGCUSActionWindow()
++#
++#   Display action select window.
++#
++# Input:
++#   insScreen  : screen instance
++#   lstSubject : install type subject list
++#      [ str ]
++#        str : subject of each install type
++#   iPosition  : current entry position
++#   group_hotkey  : show group_hotkey
++#   title             : title of grid
++# Output:
++#   str   : pressed hotkey "ENTER", " ", "i", or "x"
++#   int   : position
++# ------------------------------------------------------------
++def PKGCUSActionWindow(insScreen, lstSubject, iPosition, group_hotkey=False, title="Select install type"):
++
++    # Create CheckboxTree instance
++    (main_width, main_height) = GetHotKeyMainSize(insScreen)
++
++    if len(lstSubject) > main_height:
++        scroll = 1
++    else:
++        scroll = 0
++
++    li = snack.Listbox(main_height, scroll=scroll, width=main_width)
++
++    idx = 0
++    for idx in range(len(lstSubject)):
++        str = "%s" % lstSubject[idx][0]
++        li.append(str+"  --->", idx)
++
++    num_subject = len(lstSubject)
++    if num_subject > iPosition:
++        li.setCurrent(iPosition)
++    else:
++        li.setCurrent(num_subject - 1)
++    # Create Text instance
++    t1 = snack.Textbox(main_width, 1, "-" * main_width)
++    if group_hotkey == True:
++        text = "  F4:Back  F5:Info  F6:Group  F9:Exit"
++        g = snack.GridForm(insScreen, "Select group", 1, 3)
++    else:
++        text = "  F4:Back  F5:Info  F9:Exit"
++        g = snack.GridForm(insScreen, title, 1, 3)
++
++    t2 = snack.Textbox(main_width, 1, text)
++
++    #insScreen.pushHelpLine(" ")
++    insScreen.pushHelpLine(text)
++    # Create Grid instance
++    g.add(li, 0, 0)
++    #g.add(t1, 0, 1, (-1, 0, -1, 0))
++    #g.add(t2, 0, 2, (0, 0, 0, -1))
++
++    myhotkeys = {"ENTER": "ENTER", \
++                 " ": " ", \
++                 "F5": "i", \
++                 "F9": "x", \
++                 "F4": "b"}
++
++    #If group exists, add group_hotkey
++    if group_hotkey == True:
++        myhotkeys["F6"] = "g"
++
++    for x in myhotkeys.keys():
++        g.addHotKey(x)
++
++    # Display window
++    while True:
++        result = g.run()
++        if result in myhotkeys:
++            idx = li.current()
++            break
++
++    #return
++    insScreen.popHelpLine()
++    insScreen.popWindow()
++    return (myhotkeys[result], idx)
++
++#------------------------------------------------------------
++# def PKGINSTPackageInfoWindow()
++#
++#   Display install package information window.
++#
++# Input:
++#   insScreen            : screen instance
++#   pkg               : selected package info list
++#     [str, str, str, long, str, str, [str]]
++#       str  : name
++#       str  : version
++#       str  : release
++#       long : size
++#       str  : licence
++#       str  : summary
++#       str  : description
++# Output:
++#   None
++#------------------------------------------------------------
++def PKGINSTPackageInfoWindow(insScreen, pkg):
++    # Create Main Text
++    (main_width, main_height) = GetHotKeyMainSize(insScreen)
++    name     = pkg.name
++    ver      = pkg.version
++    rel      = pkg.release
++    arch     = pkg.arch
++    size     = format_number(float(pkg._size))
++    repo     = pkg.repoid
++    summ     = pkg.summary
++    url      = pkg.url
++    license  = pkg.license
++    desc     = pkg.description
++
++    deplist = []
++    for req in sorted([str(req) for req in pkg.requires]):
++        deplist.append(req)
++
++    deplist = sorted(list(set(deplist)))
++
++    wrapper = textwrap.TextWrapper(width = main_width - 2)
++
++    main_text = []
++
++    main_text.append("Name    : %s\n" % name)
++    main_text.append("Version : %s\n" % ver)
++    main_text.append("Release : %s\n" % rel)
++    main_text.append("Arch    : %s\n" % arch)
++    main_text.append("Size    : %s\n" % size)
++    main_text.append("Repo    : %s\n" % repo)
++    main_text.append("License : %s\n\n" % license)
++
++    main_text.append("Summary:\n")
++    wrapper.initial_indent    = "  "
++    wrapper.subsequent_indent = "  "
++    main_text.append(wrapper.fill(summ) + "\n\n")
++
++    main_text.append("Description:\n")
++    main_text.append(wrapper.fill(desc) + "\n\n")
++    main_text.append("Dependency:\n")
++    for dep in deplist:
++        main_text.append(wrapper.fill(str(dep)) + "\n")
++
++    main_join_text = "".join(main_text)
++    del main_text
++
++    # Display information window
++    HotkeyInfoWindow(insScreen, "Package information", main_join_text, \
++                     main_width, main_height, {"F4" : "b"}, "F4:Back")
++
++#------------------------------------------------------------
++# def ButtonInfoWindow()
++#
++#   Display information window for Button mode.
++#
++# Input:
++#   insScreen : screen instance
++#   sTitle    : title string
++#   sText     : main text
++#   iWidth    : width of main text
++#   iHeight   : height of main text
++#   lstButtons: Button list [button name1, button name2, ...]
++# Output:
++#   str       : initial character in pressed button name
++#------------------------------------------------------------
++def ButtonInfoWindow(insScreen, sTitle, sText, iWidth, iHeight, lstButtons):
++
++    # Get line number
++    length = len(sText)
++    index = 0
++    count = 0
++    scroll = 0
++    while index < length:
++        if sText[index] == "\n":
++            count += 1
++            if count > iHeight:
++                scroll = 1
++                break
++        index += 1
++
++    # Create Text instance
++    t1 = snack.Textbox(iWidth - scroll * 2, iHeight, sText, scroll)
++
++    # Create Button instance
++    bb = snack.ButtonBar(insScreen, lstButtons)
++
++    # Create Grid instance
++    g = snack.GridForm(insScreen, sTitle, 1, 2)
++    g.add(t1, 0, 0)
++    g.add(bb, 0, 1, (0, 1, 0, -1))
++
++    # Display window
++    while True:
++        result = bb.buttonPressed(g.run())
++
++        rcode = None
++        for x in lstButtons:
++            if result == x.lower():
++                rcode = x[0].lower()
++                break
++        if rcode != None:
++            break
++
++    insScreen.popWindow()
++    return rcode
++
++#------------------------------------------------------------
++# def GetButtonMainSize()
++#
++#   Get best full screen main object size for Button mode
++#
++# Input:
++#   insScreen : screen instance
++# Output:
++#   int       : width
++#   int       : height
++#------------------------------------------------------------
++def GetButtonMainSize(insScreen):
++    (width, height) = GetWindowSize(insScreen)
++
++    width -= 8
++
++    # It is not centered well only by doing -12 when the Height is an Odd.
++    # In addition, it is necessary to do 1.
++    height -= (12 - (height % 2))
++
++    return (width, height)
++
++def _make_grid_search(insScreen, search_id):
++
++    l = snack.Label("Search Value:")
++    l1 = snack.Label(" ")
++    e = snack.Entry(30, search_id)
++    b = snack.ButtonBar(insScreen,(("Search","search"),("Search off","cancel")))
++
++    g = snack.GridForm(insScreen, "Enter Search String", 3, 6)
++    g.add(l, 0, 1)
++    g.add(l1,0, 2)
++    g.add(e, 0, 3)
++    g.add(l1,0, 4)
++    g.add(b, 0, 5)
++
++    return e, b, g
++
++def _make_grid_input_path(insScreen, title, label, strText):
++
++    l = snack.Label(label)
++    l1 = snack.Label(" ")
++    e = snack.Entry(50, strText)
++    b = snack.ButtonBar(insScreen,(("   OK   ", "ok"), (" Cancel ", "cancel")))
++
++    g = snack.GridForm(insScreen, title, 3, 6)
++    g.add(l, 0, 1)
++    g.add(l1,0, 2)
++    g.add(e, 0, 3)
++    g.add(l1,0, 4)
++    g.add(b, 0, 5)
++
++    return e, b, g
++
++def SampleMissWindow(insScreen, error_str):
++    buttons = ['  OK  ']
++    (w, h) = GetButtonMainSize(insScreen)
++    rr = ButtonInfoWindow(insScreen, "  Error !  ", error_str, w, h, buttons)
++    return
++
++#------------------------------------------------------------
++# def PKGINSTPathInputWindow()
++#
++#   Display a window which you can input a path.
++#
++# Input:
++#       title : Title of the window
++#       label : A text aim to guide the users operation
++# Output:
++#   path   : path you have inputed
++#------------------------------------------------------------
++def PKGINSTPathInputWindow(insScreen, check_dir_exist, title, label, text_prev=""):
++
++    rtn_sts = None
++
++    while rtn_sts == None:
++        (e, b, g) = _make_grid_input_path(insScreen, title, label , text_prev)
++        r = g.runOnce()
++        insScreen.popWindow()
++        str = e.value()
++
++        result = b.buttonPressed(r)
++        if b.buttonPressed(r) == "ok":
++            #  judge if or not the input is correct
++            if check_dir_exist :
++                if os.path.isdir(str) or os.path.isfile(str):
++                    rtn_sts=str
++                else:
++                    buttons = ['  OK  ']
++                    (w, h) = GetButtonMainSize(insScreen)
++                    rr = ButtonInfoWindow(insScreen, "  Error !  ", "Not a correct path! Input again, please !", \
++                                          w, h, buttons)
++            else:
++                real_path=os.path.realpath(str)
++                folder=os.path.split(real_path)
++                folder='/'.join(folder[:-1])
++                if os.path.isdir(folder):
++                    rtn_sts=real_path
++                else:
++                    buttons = ['  OK  ']
++                    (w, h) = GetButtonMainSize(insScreen)
++                    rr = ButtonInfoWindow(insScreen, \
++                                          "  Error !  ", \
++                                          "The path but the last folder must exist. Please check it ! ", \
++                                          w, h, buttons)
++        else:
++            if str:
++                text_prev = str
++            rtn_sts = text_prev
++            break
++
++    insScreen.popWindow()
++    return (result, rtn_sts)
++
++def PKGINSTPackageSearchWindow(insScreen):
++
++    search_id = ""
++    rtn_sts = None
++
++    while rtn_sts == None:
++
++        (e, b, g) = _make_grid_search(insScreen, search_id)
++        r = g.runOnce()
++        insScreen.popWindow()
++
++        sts = e.value()
++
++        if b.buttonPressed(r) == "search":
++            regexp = re.compile(r'^[-\+\*/\:;,.\?_&$#\"\'!()0-9A-Za-z]+$')
++            rs = regexp.search(sts)
++            if rs != None:
++                rtn_sts = sts
++            else:
++                buttons = ['OK']
++                (w, h) = GetButtonMainSize(insScreen)
++                rr = ButtonInfoWindow(insScreen, "Error!", "Search Value Invalid!", \
++                                  w, h, buttons)
++        else:
++            break
++        search_id = sts
++
++    return rtn_sts
++
++#------------------------------------------------------------
++# def PKGTypeSelectWindow()
++#
++#   Display locale doc and dbg pacakges select window.
++#
++# Input:
++#   pkgTypeList   : package type list
++#     ["locale", "doc", "dbg"]
++#      "locale" = True/False : install/not install *-locale/*-localedata package
++#      "doc"    = True/False : install/not install doc package
++#      "dbg"    True/False : install/not install dbg package
++#      "static"    True/False : install/not install *-staticdev package
++#      "ptest"    True/False : install/not install *-ptest package
++# Output:
++#   pkgTypeList   : select result
++#------------------------------------------------------------
++def PKGTypeSelectWindow(insScreen, pkgTypeList, position = 0):
++
++    iPosition = position
++    # Create CheckboxTree instance
++    (main_width, main_height) = GetHotKeyMainSize(insScreen)
++    main_height -= 2
++
++    #print " packages = %s" % len(packages)
++    if len(pkgTypeList) > main_height:
++        scroll = 1
++    else:
++        scroll = 0
++
++    hotkey_base_text = "  F3:Next  F4:Back  F5:Info  F9:Exit"
++    wrapper = textwrap.TextWrapper(width = main_width)
++    hotkey_text = wrapper.fill(hotkey_base_text)
++
++    insScreen.pushHelpLine(hotkey_text)
++    if hotkey_text != hotkey_base_text:
++        main_height -= 1
++        hotkey_line = 2
++    else:
++        hotkey_line = 1
++
++    li = snack.Listbox(main_height, scroll = scroll, width = main_width)
++    idx = 0
++    for x in pkgTypeList:
++        if x.status:
++            status = "*"
++        else:
++            status = " "
++        str = "%s [%s]" % (x.name, status)
++
++        li.append(str, idx)
++        idx += 1
++    # Set position
++    num_type = len(pkgTypeList)
++    if num_type > 1:
++        if num_type <= iPosition:
++            iPosition = num_typr - 1
++        if  num_type > (iPosition + main_height / 2):
++            before_position = (iPosition + main_height / 2)
++        else:
++            before_position = num_type - 1
++    li.setCurrent(before_position)
++    li.setCurrent(iPosition)
++
++    t1 = snack.Textbox(main_width, 1, "-" * main_width)
++    t2 = snack.Textbox(main_width, hotkey_line, hotkey_text)
++
++    # Create Grid instance
++    title = "Customize special type packages"
++
++    g = snack.GridForm(insScreen, title, 1, 3)
++
++    #g.add(t1, 0, 2)
++    #g.add(t2, 0, 4, (0, 0, 0, -1))
++    g.add(li, 0, 0)
++
++############# append test key 'S' ####
++    myhotkeys = {"ENTER" : "ENTER", \
++                 " "     : " ", \
++                 "F3"     : "n", \
++                 "F4"     : "b", \
++                 "F5"     : "i", \
++                 "F9"     : "x"}
++
++    for x in myhotkeys.keys():
++        g.addHotKey(x)
++#####################################
++    while True:
++        result = g.run()
++        idx = li.current()
++        if result in myhotkeys:
++            if myhotkeys[result] == "ENTER" or \
++               myhotkeys[result] == " ":
++                curr_type = pkgTypeList[idx]
++                if not curr_type.status:
++                    curr_type.status = True
++                    newsign = "*"
++                else:
++                    curr_type.status = False
++                    newsign = " "
++                item = "%s [%s]" % (curr_type.name, newsign)
++                li.replace(item, idx)
++                idx += 1
++
++                if idx >= num_type:
++                    idx = num_type - 1
++                li.setCurrent(idx)
++            else:
++                break
++
++    #return
++    insScreen.popHelpLine()
++    insScreen.popWindow()
++    return (myhotkeys[result], idx, pkgTypeList)
++
++
++def PKGTypeSelectWindowCtrl(insScreen, pkgTypeList):
++    idx = 0
++    while True:
++        (hkey, idx, pkgTypeList) = PKGTypeSelectWindow(insScreen, pkgTypeList, idx)
++        if hkey == "i":
++            # info
++            description = pkgTypeList[idx].description
++            subject = pkgTypeList[idx].name
++            PKGINSTTypeInfoWindow(insScreen, subject, description)
++
++        elif hkey == "x":
++            # exit
++            exit_hkey = HotkeyExitWindow(insScreen)
++            if exit_hkey == "y":
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++                    sys.exit(0)
++
++        elif hkey == "n":
++            return ("n", pkgTypeList)
++        elif hkey == "b":
++            return ("b", pkgTypeList)
++
++#------------------------------------------------------------
++# def PKGINSTPackageWindow()
++#
++#   Display package select window.
++#
++# Input:
++#   insScreen   : screen instance
++#   lstPackage  : package info list
++#     [str, str, i]
++#      str      : package name
++#      str      : package summary
++#      i        : select status
++#   dispPackage ; disp package info list
++#   iPosition   : current entry position
++#   lTargetSize : target size
++#   lHostSize   : host size
++#   search      : search string
++#   install_type: INSTALL or REMOVE or UPDATE
++#   group_hotkey: show group_hotkey
++# Output:
++#   str   : pressed hotkey "r", "f", "c", "n", "b", "d", "s", "i", or "x"
++#   int   : position
++#   lst   : package info list (updated)
++#------------------------------------------------------------
++def PKGINSTPackageWindow(insScreen, packages, selected_packages, iPosition, lTargetSize, lHostSize, search, \
++                                                                                               install_type, group_hotkey=False):
++    installed_pkgs = 0
++    numChange=True      #Select or unselect operation that lead selected number change
++
++
++    # Create CheckboxTree instance
++    (main_width, main_height) = GetHotKeyMainSize(insScreen)
++    main_height -= 2
++
++    #print " packages = %s" % len(packages)
++    if len(packages) > main_height:
++        scroll = 1
++    else:
++        scroll = 0
++
++    if group_hotkey == True:
++        hotkey_base_text = "  F1:select/unselect All  F2:Search  F3:Next  F4:Back  F5:Info  F6:Group  F9:Exit"
++    else:
++        hotkey_base_text = "  F1:select/unselect All  F2:Search  F3:Next  F4:Back  F5:Info  F9:Exit"
++
++    #insScreen.pushHelpLine(" ")
++    insScreen.pushHelpLine(hotkey_base_text)
++    wrapper = textwrap.TextWrapper(width = main_width)
++    hotkey_text = wrapper.fill(hotkey_base_text)
++    if hotkey_text != hotkey_base_text:
++        main_height -= 1
++        hotkey_line = 2
++    else:
++        hotkey_line = 1
++
++    li = snack.Listbox(main_height, scroll = scroll, width = main_width)
++
++    idx = 0
++    for x in packages:
++        if install_type==ACTION_INSTALL and x.installed :
++            status = "I"
++            installed_pkgs += 1
++        elif x in selected_packages:
++            status = SIGN_SELECT[install_type]
++        else:
++            status = " "
++        str = "[%s] %s " % (status, x.name)
++
++        li.append(str, idx)
++        idx += 1
++    # Set position
++    num_package = len(packages)
++    before_position = 0
++    if num_package > 1:
++        if num_package <= iPosition:
++            iPosition = num_package - 1
++        if  num_package > (iPosition + main_height / 2):
++            before_position = (iPosition + main_height / 2)
++        else:
++            before_position = num_package - 1
++    li.setCurrent(int(before_position))
++    li.setCurrent(int(iPosition))
++
++    # Create Text instance
++    text=""
++    t1 = snack.Textbox(main_width, 1, "-" * main_width)
++    t2 = snack.Textbox(main_width, 1, text)
++    t3 = snack.Textbox(main_width, 1, "-" * main_width)
++    t4 = snack.Textbox(main_width, hotkey_line, hotkey_text)
++
++    # Create Grid instance
++    if search == None:
++        title = "Select package"
++    else:
++        title = "Select package - (%s)" % search
++
++    g = snack.GridForm(insScreen, title, 1, 3)
++    g.add(li, 0, 0)
++    g.add(t1, 0, 1, (-1, 0, -1, 0))
++    g.add(t2, 0, 2, (0, 0, 0, 0))
++    #g.add(t3, 0, 3, (-1, 0, -1, 0))
++    #g.add(t4, 0, 4, (0, 0, 0, -1))
++
++
++
++
++############# append test key 'S' ####
++    myhotkeys = {"ENTER" : "ENTER", \
++                 " "     : " ", \
++                 "F3"     : "n", \
++                 "F4"     : "b", \
++                 "F2"     : "r", \
++                 "F5"     : "i", \
++                 "F9"     : "x", \
++                 "F1"     : "a"}
++
++    #If group exists, add group_hotkey
++    if group_hotkey == True:
++        myhotkeys["F6"] = "g"
++
++    for x in myhotkeys.keys():
++        g.addHotKey(x)
++
++#####################################
++    while True:
++
++        if numChange:
++            if install_type == ACTION_INSTALL:
++                text = "All Packages [%ld]    Installed Packages [%ld]    Selected Packages [%ld]" % \
++                       (num_package, installed_pkgs, len(selected_packages))
++            else:
++                text = "All Packages [%ld]    Selected Packages [%ld]" % \
++                       (num_package, len(selected_packages))
++            t2.setText(text)
++            numChange = False
++
++        result = g.run()
++        idx = li.current()
++        if result in myhotkeys:
++            if myhotkeys[result] == "ENTER" or \
++               myhotkeys[result] == " ":
++                numChange=True
++                li = _StatusToggle(li, myhotkeys[result], idx, selected_packages, \
++                                                          packages, install_type)
++                idx += 1
++                if idx >= num_package:
++                    idx = num_package - 1
++                li.setCurrent(idx)
++            elif myhotkeys[result]=="a":        ###
++                li = _SelectAll(li, myhotkeys[result],num_package, selected_packages, \
++                                                         packages, install_type)
++                li.setCurrent(idx)
++                numChange = True
++            else:
++                break
++
++    #return
++    insScreen.popHelpLine()
++    insScreen.popWindow()
++    return (myhotkeys[result], idx, selected_packages)
++
++#------------------------------------------------------------
++# def PKGINSTDebuginfoWindow()
++#
++#   Display package select window.
++#
++# Input:
++#   insScreen   : screen instance
++#   lstDebugPkg : package info list
++#     [str, str, i]
++#      str      : package name
++#      str      : package summary
++#      i        : select status
++#   iPosition   : current entry position
++#   lTargetSize : target size
++#   lHostSize   : host size
++# Output:
++#   str   : pressed hotkey "c", "n", "b", "i", or "x"
++#   int   : position
++#   lst   : package info list (updated)
++#------------------------------------------------------------
++def PKGINSTDebuginfoWindow(insScreen, lstDebugPkg, selected_packages, iPosition, \
++                         lTargetSize, lHostSize):
++
++    installed_pkgs = 0
++    # Create CheckboxTree instance
++
++    (main_width, main_height) = GetHotKeyMainSize(insScreen)
++    main_height -= 2
++
++    if len(lstDebugPkg) > main_height:
++        scroll = 1
++    else:
++        scroll = 0
++
++    hotkey_base_text = "SPACE/ENTER:select/unselect  N:Next  B:Back  I:Info  X:eXit"
++    wrapper = textwrap.TextWrapper(width = main_width)
++    hotkey_text = wrapper.fill(hotkey_base_text)
++    if hotkey_text != hotkey_base_text:
++        main_height -= 1
++        hotkey_line = 2
++    else:
++        hotkey_line = 1
++
++    li = snack.Listbox(main_height, scroll = scroll, width = main_width)
++
++    idx = 0
++    for x in lstDebugPkg:
++        if x.installed:
++            status = "I"
++            installed_pkgs += 1
++        elif x in selected_packages:
++            status = "*"
++        else:
++            status = " "
++        str = "[%s] %s " % (status, x.name)
++
++        li.append(str, idx)
++        idx += 1
++
++    # Set position
++    num_package = len(lstDebugPkg)
++    if num_package <= iPosition:
++        iPosition = num_package - 1
++    if  num_package > (iPosition + main_height / 2):
++        before_position = (iPosition + main_height / 2)
++    else:
++        before_position = num_package - 1
++    li.setCurrent(before_position)
++    li.setCurrent(iPosition)
++
++    # Create Text instance
++    t1 = snack.Textbox(main_width, 1, "-" * main_width)
++    text = "All Packages [%ld]    Installed Packages    [%ld] Selected Packages [%ld]" % \
++          (num_package, installed_pkgs, len(selected_packages))
++
++    t2 = snack.Textbox(main_width, 1, text)
++    t3 = snack.Textbox(main_width, 1, "-" * main_width)
++    t4 = snack.Textbox(main_width, hotkey_line, hotkey_text)
++
++    # Create Grid instance
++    g = snack.GridForm(insScreen, "Select debuginfo packages", 1, 5)
++    g.add(li, 0, 0)
++    g.add(t1, 0, 1, (-1, 0, -1, 0))
++    g.add(t2, 0, 2)
++    g.add(t3, 0, 3, (-1, 0, -1, 0))
++    g.add(t4, 0, 4, (0, 0, 0, -1))
++
++
++
++############# append test key 'S' ####
++    myhotkeys = {"ENTER" : "ENTER", \
++                 " "     : " ", \
++                 "n"     : "n", \
++                 "N"     : "n", \
++                 "b"     : "b", \
++                 "B"     : "b", \
++                 "i"     : "i", \
++                 "I"     : "i", \
++                 "x"     : "x", \
++                 "X"     : "x"}
++    for x in myhotkeys.keys():
++        g.addHotKey(x)
++#####################################
++
++
++    # Display window
++    while True:
++        result = g.run()
++        idx = li.current()
++        if result in myhotkeys:
++            if myhotkeys[result] == "ENTER" or \
++               myhotkeys[result] == " ":
++                li = _StatusToggle(li, myhotkeys[result], idx, selected_packages, lstDebugPkg)
++                idx += 1
++                if idx >= num_package:
++                    idx = num_package - 1
++                li.setCurrent(idx)
++            else:
++                break
++
++    insScreen.popWindow()
++    return (myhotkeys[result], idx, selected_packages)
++
++def ConfirmGplv3Window(insScreen, packages):
++    if insScreen == None:
++        print ("error ConfirmGplv3Window: the screen is None")
++    # Create CheckboxTree instance
++    (main_width, main_height) = GetHotKeyMainSize(insScreen)
++    main_height -= 2
++
++    if len(packages) > main_height:
++        scroll = 1
++    else:
++        scroll = 0
++
++    hotkey_base_text = "These GPLv3 packages are depended"
++    wrapper = textwrap.TextWrapper(width = main_width)
++    hotkey_text = wrapper.fill(hotkey_base_text)
++    if hotkey_text != hotkey_base_text:
++        main_height -= 1
++        hotkey_line = 2
++    else:
++        hotkey_line = 1
++
++    li = snack.Listbox(main_height, scroll = scroll, width = main_width)
++
++    idx = 0
++    for x in packages:
++        li.append(x.name, idx)
++        idx += 1
++
++    # Set position
++    iPosition=0
++    li.setCurrent(iPosition)
++
++    # Create Text instance
++    t1 = snack.Textbox(main_width, 1, "-" * main_width)
++    t4 = snack.Textbox(main_width, hotkey_line, hotkey_text)
++
++    # Create the help line
++    insScreen.pushHelpLine("  F3:Next  F4:Back  F9:Exit")
++
++    # Create Grid instance
++    title = "GPLv3 that be depended"
++
++    g = snack.GridForm(insScreen, title, 1, 5)
++    g.add(li, 0, 0)
++    g.add(t1, 0, 1, (-1, 0, -1, 0))
++    g.add(t4, 0, 4, (0, 0, 0, 0))
++
++############# append test key 'S' ####
++    myhotkeys = {"F3"     : "n", \
++                 "F4"     : "b", \
++                 "F9"     : "x"}
++    for x in myhotkeys.keys():
++        g.addHotKey(x)
++#####################################
++    result = g.run()
++    if result in myhotkeys:
++        if myhotkeys[result] == "b" or myhotkeys[result] == "n":
++            insScreen.popWindow()
++            return (myhotkeys[result])
++
++        elif myhotkeys[result] == "x":
++            # exit
++            insScreen.popHelpLine()
++            insScreen.popWindow()
++            exit_hkey = HotkeyExitWindow(insScreen)
++            if exit_hkey == "y":
++                if insScreen != None:
++                    StopHotkeyScreen(insScreen)
++                    insScreen = None
++                    sys.exit(0)
++
+diff --git a/samples/busybox b/samples/busybox
+new file mode 100644
+index 0000000..fb36bf8
+--- /dev/null
++++ b/samples/busybox
+@@ -0,0 +1,7 @@
++base-passwd
++base-files
++busybox
++busybox-mdev
++busybox-syslog
++busybox-udhcpc
++busybox-udhcpd
+diff --git a/samples/systemd b/samples/systemd
+new file mode 100644
+index 0000000..22b7b5b
+--- /dev/null
++++ b/samples/systemd
+@@ -0,0 +1,5 @@
++systemd
++busybox
++systemd-analyze
++systemd-initramfs
++systemd-bash-completion
+--
+2.7.4
+
diff --git a/meta/recipes-devtools/dnf/dnf/oe-remote.repo.sample b/meta/recipes-devtools/dnf/dnf/oe-remote.repo.sample
new file mode 100644
index 0000000..05e8cd6
--- /dev/null
+++ b/meta/recipes-devtools/dnf/dnf/oe-remote.repo.sample
@@ -0,0 +1,6 @@
+[base]
+name=myrepo
+baseurl=http://127.0.0.1/oe_repo/
+enabled=1
+gpgcheck=0
+
diff --git a/meta/recipes-devtools/dnf/dnf_2.7.5.bb b/meta/recipes-devtools/dnf/dnf_2.7.5.bb
index df60d73..8f7208c 100644
--- a/meta/recipes-devtools/dnf/dnf_2.7.5.bb
+++ b/meta/recipes-devtools/dnf/dnf_2.7.5.bb
@@ -10,8 +10,11 @@ SRC_URI = "git://github.com/rpm-software-management/dnf.git \
            file://0005-Do-not-prepend-installroot-to-logdir.patch \
            file://0029-Do-not-set-PYTHON_INSTALL_DIR-by-running-python.patch \
            file://0030-Run-python-scripts-using-env.patch \
+           file://0001-dnf-tui-plugin.patch \
            "

+SRC_URI_append_class-target = "file://oe-remote.repo.sample"
+
 SRCREV = "564c44667c7014843fa6f1732621093114ec59b2"
 UPSTREAM_CHECK_GITTAGREGEX = "(?P<pver>\d+(\.\d+)+)"

@@ -19,7 +22,7 @@ S = "${WORKDIR}/git"

 inherit cmake gettext bash-completion distutils3-base systemd

-DEPENDS += "libdnf librepo libcomps python3-iniparse"
+DEPENDS += "libdnf librepo libcomps python3-iniparse libnewt-python"

 # manpages generation requires http://www.sphinx-doc.org/
 EXTRA_OECMAKE = " -DWITH_MAN=0 -DPYTHON_INSTALL_DIR=${PYTHON_SITEPACKAGES_DIR} -DPYTHON_DESIRED=3"
@@ -49,6 +52,29 @@ RDEPENDS_${PN}_class-target += " \
   python3-gpg \
   "

+RDEPENDS_${PN}_class-nativesdk += " \
+  python3-core \
+  python3-codecs \
+  python3-netclient \
+  python3-email \
+  python3-threading \
+  python3-distutils \
+  python3-logging \
+  python3-fcntl \
+  librepo \
+  python3-shell \
+  libcomps \
+  libdnf \
+  python3-sqlite3 \
+  python3-compression \
+  python3-rpm \
+  python3-iniparse \
+  python3-json \
+  python3-curses \
+  python3-misc \
+  python3-gpg \
+  "
+
 RRECOMMENDS_${PN}_class-target += "gnupg"

 # Create a symlink called 'dnf' as 'make install' does not do it, but
@@ -66,6 +92,24 @@ do_install_append_class-native() {
                 RPM_NO_CHROOT_FOR_SCRIPTS=1
 }

+do_install_append_class-nativesdk() {
+        create_wrapper ${D}/${bindir}/dnf \
+                RPM_CONFIGDIR=${SDKPATHNATIVE}${libdir_nativesdk}/rpm \
+                RPM_NO_CHROOT_FOR_SCRIPTS=1
+        install -d ${D}${datadir}/dnf
+        install -m 0755 ${S}/samples/* ${D}${datadir}/dnf
+        install -d ${D}${PYTHON_SITEPACKAGES_DIR}/dnf-plugins/mkimg
+        install -m 0755 ${S}/dnf-plugins/mkimg/* ${D}${PYTHON_SITEPACKAGES_DIR}/dnf-plugins/mkimg
+        for file in $(ls ${S}/dnf-plugins/ | grep -v mkimg); do
+            install -m 0755 ${S}/dnf-plugins/$file ${D}${PYTHON_SITEPACKAGES_DIR}/dnf-plugins
+        done
+}
+
+do_install_append_class-target() {
+        install -d ${D}${sysconfdir}/yum.repos.d
+        install -m 0644 ${WORKDIR}/oe-remote.repo.sample ${D}${sysconfdir}/yum.repos.d
+}
+
 SYSTEMD_SERVICE_${PN} = "dnf-makecache.service dnf-makecache.timer \
                          dnf-automatic.service dnf-automatic.timer \
                          dnf-automatic-download.service dnf-automatic-download.timer \
--
2.7.4
